
𝐭𝐡𝐞𝐨𝐫𝐲 𝟐.𝟏: 𝐭𝐡𝐞 𝐏𝐞𝐚𝐧𝐨 𝐚𝐱𝐢𝐨𝐦𝐬
𝐄𝐱𝐭𝐞𝐧𝐝𝐞𝐝 𝐭𝐡𝐞𝐨𝐫𝐢𝐞𝐬:
The following theories are extended by 𝐭𝐡𝐞𝐨𝐫𝐲 𝟐.𝟏: 𝐭𝐡𝐞 𝐏𝐞𝐚𝐧𝐨 𝐚𝐱𝐢𝐨𝐦𝐬.
	 ⁃ ℱ

𝐒𝐢𝐦𝐩𝐥𝐞-𝐨𝐛𝐣𝐜𝐭 𝐝𝐞𝐜𝐥𝐚𝐫𝐚𝐭𝐢𝐨𝐧𝐬:
Let ⊥ be a simple-objct denoted as ⌜ ⊥ ⌝.
Let ⊤ be a simple-objct denoted as ⌜ ⊤ ⌝.
Let class-of-classes be a simple-objct denoted as ⌜ class-of-classes ⌝.
Let theory-class be a simple-objct denoted as ⌜ theory-class ⌝.
Let false be a simple-objct denoted as ⌜ false ⌝.
Let true be a simple-objct denoted as ⌜ true ⌝.
Let truth-values be a simple-objct denoted as ⌜ truth-values ⌝.
Let propositional-relations-class be a simple-objct denoted as ⌜ propositional-relations-class ⌝.
Let proposition-class be a simple-objct denoted as ⌜ proposition-class ⌝.
Let contradictory-theories be a simple-objct denoted as ⌜ contradictory-theories ⌝.
Let contradictory-statement be a simple-objct denoted as ⌜ contradictory-statement ⌝.
Let 0 be a simple-objct denoted as ⌜ 0 ⌝.
Let 1 be a simple-objct denoted as ⌜ 1 ⌝.
Let 2 be a simple-objct denoted as ⌜ 2 ⌝.
Let 3 be a simple-objct denoted as ⌜ 3 ⌝.
Let 4 be a simple-objct denoted as ⌜ 4 ⌝.
Let natural-number be a simple-objct denoted as ⌜ natural-number ⌝.

𝐑𝐞𝐥𝐚𝐭𝐢𝐨𝐧 𝐝𝐞𝐜𝐥𝐚𝐫𝐚𝐭𝐢𝐨𝐧𝐬:
Let =₁ be a binary relation denoted as ⌜ =₁ ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ =₁ 𝐱₂ ⌝).
Let ∧ be a binary relation denoted as ⌜ ∧ ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ ∧ 𝐱₂ ⌝).
Let ⟹ be a binary relation denoted as ⌜ ⟹ ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ ⟹ 𝐱₂ ⌝).
Let ¬ be a unary relation denoted as ⌜ ¬ ⌝, that signals well-formed formulae in prefix-operator syntax (e.g.: ⌜ ¬𝐱 ⌝).
Let ⟺ be a binary relation denoted as ⌜ ⟺ ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ ⟺ 𝐱₂ ⌝).
Let ∈ be a binary relation denoted as ⌜ ∈ ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ ∈ 𝐱₂ ⌝).
Let ∨ be a binary relation denoted as ⌜ ∨ ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ ∨ 𝐱₂ ⌝).
Let ≠ be a binary relation denoted as ⌜ ≠ ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ ≠ 𝐱₂ ⌝).
Let =₂ be a binary relation denoted as ⌜ =₂ ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ =₂ 𝐱₂ ⌝).
Let is be a binary relation denoted as ⌜ is ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ is 𝐱₂ ⌝).
Let relation-declaration be a binary relation denoted as ⌜ relation-declaration ⌝, that signals well-formed formulae in function-call syntax (e.g.: ⌜ relation-declaration(𝐱₁, 𝐱₂ ,… ,𝐱ₙ) ⌝).
Let simple-objct-declaration be a binary relation denoted as ⌜ simple-objct-declaration ⌝, that signals well-formed formulae in function-call syntax (e.g.: ⌜ simple-objct-declaration(𝐱₁, 𝐱₂ ,… ,𝐱ₙ) ⌝).
Let theory-declaration be a binary relation denoted as ⌜ theory-declaration ⌝, that signals well-formed formulae in function-call syntax (e.g.: ⌜ theory-declaration(𝐱₁, 𝐱₂ ,… ,𝐱ₙ) ⌝).
Let theory-extension be a binary relation denoted as ⌜ theory-extension ⌝, that signals well-formed formulae in function-call syntax (e.g.: ⌜ theory-extension(𝐱₁, 𝐱₂ ,… ,𝐱ₙ) ⌝).
Let variable-declaration be a binary relation denoted as ⌜ variable-declaration ⌝, that signals well-formed formulae in function-call syntax (e.g.: ⌜ variable-declaration(𝐱₁, 𝐱₂ ,… ,𝐱ₙ) ⌝).
Let is-a be a binary relation denoted as ⌜ is-a ⌝, that signals well-formed formulae in infix-operator syntax (e.g.: ⌜ 𝐱₁ is-a 𝐱₂ ⌝).
Let ++ be a unary relation denoted as ⌜ ++ ⌝, that signals well-formed formulae in postfix-operator syntax (e.g.: ⌜ 𝐱++ ⌝).

𝐓𝐡𝐞𝐨𝐫𝐲 𝐞𝐥𝐚𝐛𝐨𝐫𝐚𝐭𝐢𝐨𝐧:

𝐍𝐚𝐭𝐮𝐫𝐚𝐥 𝐥𝐚𝐧𝐠𝐮𝐚𝐠𝐞 𝐚𝐱𝐢𝐨𝐦 𝟐.𝟏: “0 is a natural number.”

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝐚: (0 is-a natural-number)

𝐍𝐚𝐭𝐮𝐫𝐚𝐥 𝐥𝐚𝐧𝐠𝐮𝐚𝐠𝐞 𝐚𝐱𝐢𝐨𝐦 𝟐.𝟐.𝟏: “If n is a natural number, then n++ is a
	natural number.”

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟐.𝟐: ((n₁ is-a natural-number) ⟹ ((n₁)++ is-a natural-number))

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟐.𝟑: ((0)++ is-a natural-number)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟐.𝟒: (((0)++)++ is-a natural-number)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟐.𝟓: ((((0)++)++)++ is-a natural-number)

𝙳₇: “We define 1 to be the number 0++, 2 to be the number (0++)++, 3
	to be the number ((0++)++)++,etc. (In other words, 1 := 0++, 2 :=
	1++, 3 := 2++, etc. In this text I use "x := y" to denote the
	statement that x is defined to equal y.)”

𝐅𝐨𝐫𝐦𝐚𝐥 𝐝𝐞𝐟𝐢𝐧𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟏: (1 =₂ (0)++)

𝐅𝐨𝐫𝐦𝐚𝐥 𝐝𝐞𝐟𝐢𝐧𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟐: (2 =₂ ((0)++)++)

𝐅𝐨𝐫𝐦𝐚𝐥 𝐝𝐞𝐟𝐢𝐧𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟑: (3 =₂ (((0)++)++)++)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟏.𝐛: ((0)++ =₂ 1)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟐.𝐛: (2 =₂ (1)++)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟐.𝐜: (((0)++)++ =₂ 2)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟐.𝐝: ((1)++ =₂ 2)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟑.𝐛: (3 =₂ (2)++)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟑.𝐜: ((((0)++)++)++ =₂ 3)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟑.𝐝: ((2)++ =₂ 3)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟒: (3 is-a natural-number)

𝐅𝐨𝐫𝐦𝐚𝐥 𝐝𝐞𝐟𝐢𝐧𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟑.𝟑.𝐚: (4 =₂ ((((0)++)++)++)++)

𝐍𝐚𝐭𝐮𝐫𝐚𝐥 𝐥𝐚𝐧𝐠𝐮𝐚𝐠𝐞 𝐚𝐱𝐢𝐨𝐦 𝟐.𝟑: “0 is not the successor of any natural
	number; i.e., we have n++ ≠ 0 for every natural number n.”

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟑.𝟏: ((n₂ is-a natural-number) ⟹ ((n₂)++ ≠ 0))

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟔.𝟏: (((((0)++)++)++)++ ≠ 0)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟔.𝟐: (((((0)++)++)++)++ =₂ 4)

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟏.𝟔.𝟑: (4 ≠ 0)

𝐍𝐚𝐭𝐮𝐫𝐚𝐥 𝐥𝐚𝐧𝐠𝐮𝐚𝐠𝐞 𝐚𝐱𝐢𝐨𝐦 𝟐.𝟒: “Different natural numbers must have
	different successors; i.e., if n, m are natural numbers and n ≠ m,
	then n++ ≠ m++. Equivalently, if n++ = m++, then we must have n = m.”

𝐏𝐫𝐨𝐩𝐨𝐬𝐢𝐭𝐢𝐨𝐧 𝟐.𝟒.𝟏: ((((n₃ is-a natural-number) ∧ (m is-a natural-number)) ∧ (n₃ ≠ m)) ⟹ ((n₃)++ ≠ (m)++))