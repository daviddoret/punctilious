from __future__ import annotations
import typing
import collections

# third party packages
import uuid

# package modules
import util


class Connective(tuple):
    """A `Connective` is an abstract symbol that may be assigned various (human-readable) representations,
    and that is recognized as a distinctive semantic unit.

    References:
     - Mancosu 2021, definition 2.1, p. 14, p. 15.
    """

    def __eq__(self, c) -> bool:
        """Returns `True` if this connective is equal to connective `c`, `False` otherwise.

        See :attr:`Connective.is_equal_to` for a definition of connective equality.

        :param c: A connective.
        :return: `True` if this connective is equal to connective `c`, `False` otherwise.
        """
        return self.is_equal_to(c)

    def __hash__(self):
        return self._compute_hash(self)

    def __init__(self, fallback_string_representation: str, uid: uuid.UUID | str | None = None):
        pass

    def __lt__(self, c) -> bool:
        """Returns `True` if this connective is less than connective `c`, `False` otherwise.

        See :attr:`Connective.is_less_than` for a definition of connective canonical-ordering.

        """
        return self.is_less_than(c)

    def __new__(cls, fallback_string_representation: str, uid: uuid.UUID | str | None = None):
        if uid is None:
            uid: uuid.UUID = uuid.uuid4()

        uid: uuid.UUID = util.data_validate_uid(uid)

        c = super(Connective, cls).__new__(cls, (uid, fallback_string_representation,))
        c = Connective._from_cache(c)
        return c

    def __repr__(self):
        return self.get_string_representation()

    def __str__(self):
        return self.get_string_representation()

    _cache: dict[int, Connective] = dict()  # Cache mechanism.

    _HASH_SEED: int = 11417641604436932830  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def _compute_hash(cls, o: Connective) -> int:
        """Exposes the hashing logic as a static method.

        :param o: An object that is structurally compatible with a connective.
        :return: The hash of the connective that is structurally equivalent to `o`.
        """
        return hash((Connective, cls._HASH_SEED, o.uid,))

    @classmethod
    def _from_cache(cls, o: FlexibleConnective):
        """Cache mechanism used in the constructor."""
        hash_value: int = Connective._compute_hash(o)
        if hash_value in cls._cache.keys():
            return cls._cache[hash_value]
        else:
            cls._cache[hash_value] = o
            return o

    @property
    def fallback_string_representation(self) -> str:
        """The `fallback_string_representation` of a `Connective` is a string representation
        that is always available, and will be used as a fallback value when no solution
        can be found to return a string representation matching user preferences.

        `fallback_string_representation` is an immutable property.

        By convention, the `fallback_string_representation`:
         - use a safe subset of Unicode characters that should render properly on any computer system.
         - can be naturally used in mathematical expressions or formulas.
         - use English words separated by dashes (in such a way as to constitute a single word for natural
           representation in mathematical expressions or formulas).
         - be as unambiguous as possible while not being too verbose or lengthy.

        :return: A string representation of the connective.
        """
        return tuple.__getitem__(self, 1)

    @classmethod
    def from_any(cls, o: FlexibleConnective) -> Connective:
        """Declares a connective from a Python object that can be interpreted as a connective.

        Note:
            This method is redundant with the default constructor.

        :param o: a Python object that can be interpreted as a connective.
        :return: a connective.
        """
        if isinstance(o, Connective):
            return o
        if isinstance(o, collections.abc.Iterable):
            return Connective(*o)
        if isinstance(o, collections.abc.Generator):
            return Connective(*o)
        raise util.PunctiliousException('Connective data validation failure', o=o)

    def get_string_representation(self, **user_preferences) -> str:
        """Returns the string representation of the `Connective` that best matches `user_preferences`.

        :param user_preferences:
        :return:
        """
        return self.fallback_string_representation

    def is_connective_equivalent_to(self, c: FlexibleConnective):
        """Returns `True` if this :class:`Connective` is connective-equivalent to :class:`Connective` `c`.

        Formal definition:
        A connective `c` is connective-equivalent to a connective `d` if and only if this is the same
        symbol, or equivalently they are indistinguishable.

        Note:
        connective-equivalence is a syntactic property, i.e. it is related to an abstract symbol,
        and it is not related to the diverse and sometimes ambiguous ways a connective may be represented.

        Implementation:
        As a proxy for the concept of an abstract symbol, we use the :attr:`Connective.uid` property.

        :param c:
        :return:
        """
        c: Connective = Connective.from_any(c)
        return c.uid == self.uid

    def is_equal_to(self, c: FlexibleConnective):
        """Under connective canonical ordering,
        returns `True` if the current connective is equal to `c`,
        `False` otherwise.

        See :attr:`Connective.is_less_than` for a definition of connection canonical-ordering.

        :param c: A connective.
        :return: `True` if the current connective is equal to `c`, `False` otherwise.
        """
        c: Connective = Connective.from_any(c)
        return self.is_connective_equivalent_to(c)

    def is_less_than(self, c: FlexibleConnective) -> bool:
        """Under connective canonical ordering,
        returns `True` if the current connective is less than `c`,
        `False` otherwise.

        Definition: canonical ordering of connective elements, denoted :math:`\prec`,
        is based on the 128-bit integer value of their respective UUID component,
        which is the default implementation of __lt__ in the uuid package.

        Note:
        The canonical ordering of connective-sequence being dependent on the connectives UUIDs,
        the resulting ordering may appear random to the human reader.

        :param c: A connective`.
        :return: `True` if the current :class:`NaturalNumberSequence` is equal to `s`, `False` otherwise.
        """
        c: Connective = Connective.from_any(c)
        if self.is_connective_equivalent_to(c):
            return False
        elif self.uid < c.uid:
            # Native UUID ordering.
            return True
        elif self.uid > c.uid:
            # Native UUID ordering.
            return False
        raise util.PunctiliousException("Unreachable condition")

    @property
    def uid(self) -> uuid.UUID:
        """

        `uid` is an immutable property.


        :return:
        """
        return tuple.__getitem__(self, 0)

    def yield_string_representation(self, **user_preferences) -> typing.Generator[str, None, None]:
        """Generates the string representation of the `Connective` that best matches `user_preferences`.

        :param user_preferences:
        :return:
        """
        yield self.fallback_string_representation


FlexibleConnective = typing.Union[
    Connective, tuple[uuid.UUID, str],]
