r"""

"""
from __future__ import annotations

import collections
import typing

import functools

import punctilious.util as util
import punctilious.natural_number_0_sequence_library as nn0sl
import punctilious.rooted_plane_tree_library as rptl
import punctilious.labeled_rooted_plane_tree_library as lrptl
from punctilious.labeled_rooted_plane_tree_library import LabeledRootedPlaneTree


class SyntacticStructure(lrptl.LabeledRootedPlaneTree):
    r"""A syntactic structure.

    Definition
    ------------

    A `syntactic structure` is an LRPT,
    possibly satisfying a set of defined constraints,
    that represents a mathematical object,
    but that is independent of the actual symbols used to represent it.

    Implementation
    ---------------

    Syntactic structure python classes inherit from LRPT.
    Given an LRPT `x` that satisfies the required constraints,
    the corresponding syntactic structure can be re-instantiated
    as a syntactic structure using SomeSyntacticStructure.from_lrpt(x).
    This will create a new object typed as SomeSyntacticStructure,
    giving access to the properties and methods of SomeSyntacticStructure.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticStructure, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        lrpt = super(SyntacticStructure, cls).__new__(cls, rpt, sequence)
        return lrpt

    _HASH_SEED: int = 10428185094283398729  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def from_any(
            cls,
            o: FlexibleSyntacticStructure) -> SyntacticStructure:
        if isinstance(o, SyntacticStructure):
            return o
        elif isinstance(o, lrptl.LabeledRootedPlaneTree):
            return cls.from_lrpt(x=o)
        else:
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
            return cls.from_lrpt(x=lrpt)

    @classmethod
    def from_lrpt(cls, x: lrptl.FlexibleLabeledRootedPlaneTree):
        return cls(rpt=x.t, sequence=x.s)

    @functools.cached_property
    def immediate_sub_syntactic_structures(self) -> tuple[SyntacticStructure, ...]:
        return tuple(SyntacticStructure.from_lrpt(lrpt) for lrpt in self.immediate_subtrees)

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is well-formed.

        Definition
        ------------
        A syntactic structure or LRPT is well-formed
        if it complies with all constraints applicable to that syntactic structure.

        Note
        -----
        This method must be overridden in every python subclass
        that imposes a set of constraints.

        If `True`, :meth:`SyntacticStructure.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if not isinstance(o, SyntacticStructure):
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
        return True

    def substitute_subtrees_with_map(self, m: FlexibleSyntacticStructure) -> SyntacticStructure:
        r"""Returns a new Syntactic Structure similar to the current Syntactic Structure,
         except that its subtrees present in the map `m` preimage,
         are substituted with their corresponding images,
         giving priority to the substitution of supertrees over subtrees.

        :param m: An abstract-map.
        :return: A substituted tree.

        """
        m: SyntacticStructure = SyntacticStructure.from_any(m)
        if not AbstractMap.is_well_formed(m):
            raise util.PunctiliousException("`m` is not a well-formed abstract map.", m=m,
                                            this_syntactic_structure=self)
        else:
            m: AbstractMap = AbstractMap.from_lrpt(m)
            if m.has_domain_element(self):
                # This formula must be substituted according to the substitution map.
                return m.get_value(self)
            else:
                # Pursue substitution recursively.
                t: SyntacticStructure
                s: tuple[SyntacticStructure, ...] = tuple(
                    t.substitute_subtrees_with_map(m=m) for t in self.immediate_sub_syntactic_structures)
                return SyntacticStructure.from_immediate_subtrees(n=self.main_element, s=s)


class AbstractOrderedSet(SyntacticStructure):
    r"""An abstract ordered set.

    Definition
    ------------

    An `abstract ordered set` is a syntactic structure that models a finite (computable) ordered set defined by extension.

    Given LRPT :math:`T` with sub-LRPTs :math:`t_0, t_1, \cdots, t_n`,
    its `abstract ordered set` is the ordered set :math:`(s_0, s_1, \cdots, s_m)`
    where :math:`s_i` denotes the :math:`i`-th *unique* immediate sub-LRPTs of :math:`T`, preserving order.

    Sample
    --------
    Given :math:`T = 0(3, 1, 1, 1, 2)`, the corresponding abstract ordered set is :math:`(3, 1, 2)`.

    Note
    ------

    The main element of the LRPT is not an information of the abstract ordered set, i.e.: it is dropped.

    Note
    -----------

    Every LRPT is an abstract ordered set.

    Note
    ----------

    Every LRPT of degree 0 is the empty ordered set.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractOrderedSet, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractOrderedSet, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_ordered_set()

    def __str__(self):
        return self.represent_as_ordered_set()

    _HASH_SEED: int = 16508528480418369971  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this abstract ordered set.

        Note
        ______

        This is equal to the number of unique immediate sub-LRPTs
        in the LRPT of this syntactic structure.

        This is equivalent to the degree of the LRPT
        if its immediate sub-LRPTs are unique.

        :return: an integer.
        """
        return len(self.elements)

    @functools.cached_property
    def elements(self) -> tuple[SyntacticStructure, ...]:
        r"""Returns the elements of this abstract ordered set.

        Note
        ______

        This is equivalent to the unique and immediate subtrees of the LRPT,
        preserving order,
        and typed as syntactic structures.

        :return: The elements of the ordered set, in order.
        """
        unique_elements: tuple[SyntacticStructure, ...] = ()
        for sub_ss in self.immediate_sub_syntactic_structures:
            if sub_ss not in unique_elements:
                unique_elements = unique_elements + (sub_ss,)
        return unique_elements

    @classmethod
    def from_any(cls, x: FlexibleAbstractOrderedSet) -> AbstractOrderedSet:
        if isinstance(x, AbstractOrderedSet):
            return x
        elif isinstance(x, tuple) and not isinstance(x, lrptl.LRPT):
            # This is a "pure" python tuple,
            # i.e. it is not an LRPT that inherits from python tuple.
            # This signature is interpreted the elements of the abstract ordered set.
            return cls.from_elements(*x)
        else:
            # Fallback to the original LRPT from_any() method.
            return cls.from_lrpt(x)

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> AbstractOrderedSet:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        elements = tuple(SyntacticStructure.from_any(x) for x in elements)
        return cls.from_immediate_subtrees(n=n, s=elements)

    def get_element_by_index(self, i: int) -> lrptl.LabeledRootedPlaneTree:
        if not 0 < i < self.cardinality:
            raise util.PunctiliousException("Index `i` is out of range of this abstract ordered set.")
        return self.elements[i]

    def get_element_index(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> int:
        if not self.has_element(x):
            raise util.PunctiliousException("`x` is not an element of this abstract ordered set.", x=x, poset=self)
        return self.elements.index(x)

    def has_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this set, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        x: lrptl.LabeledRootedPlaneTree = LabeledRootedPlaneTree.from_any(x)
        return self.has_immediate_subtree(x)

    def is_abstract_ordered_set_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract ordered set equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is abstract set equivalent to `y` if and only if:

        - every immediate sub-LRPT of :math:`x` is an immediate sub-LRPT of :math:`y`,
        - every immediate sub-LRPT of :math:`y` is an immediate sub-LRPT of :math:`x`,
        - the order of the first occurrence of every sub-LRPT in :math:`x`
          is equal to the order of its first occurrence in :math:`y`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to abstract set is possible because abstract ordered sets have no constraints.
        x: AbstractOrderedSet = AbstractOrderedSet.from_any(x)

        # direct comparison of elements is possible because order is considered.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed abstract ordered set.

        But because every LRPT is an abstract ordered set, this method always returns `True`.

        If `True`, :meth:`AbstractOrderedSet.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        ss: SyntacticStructure = cls.from_any(o)
        return True

    def represent_as_ordered_set(self) -> str:
        r"""Returns a string representation of the LRPT using map notation.

        :return: A string representation of this LRPT.

        """
        output = f"( "
        first = True
        for element in self.elements:
            if not first:
                output = f"{output}, "
            output = f"{output}{element}"
            first = False
        output = f"{output} )"

        return output


class AbstractMap(SyntacticStructure):
    r"""An abstract map.

    Definition
    ------------

    An `abstract map` is a syntactic structure that models a finite (computable) map defined by extension.

    Given any LRPT :math:`T` with the following constraints:
     - its degree is at least 2,
     - its first sub-LRPT is an abstract ordered set of cardinality :math:`n`, denoted as the domain,
     - its second sub-LRPT is an abstract tuple of cardinality :math:`n`, denoted as the codomain,
     - the cardinality of the domain is equal to the cardinality of the codomain,
    its `abstract map` is the map that to the :math:`i`-th element of the domain,
    maps the :math:`i`-th element of the codomain,
    and that is otherwise undefined.

    Note
    ------

    The main element of the LRPT and the main element of the first two immediate sub-LRPTs are not an information of the abstract map, i.e.: it is dropped.
    Any immediate sub-LRPT of the LRPT beyond 2 is not an information of the abstract map, i.e. it is dropped.

    Note
    -----------

    Every LRPT of degree > 1 is an abstract map.

    Note
    ----------

    If the domain is the empty ordered set, it is the empty map.

    Note
    -----------

    There are two distinctive implementations of an abstract map:

    As a set of ordered pairs:
    { (p_0, i_0), (p_1, i_1), ..., (p_n, i_n) }.

    As an ordered pair whose first element is an ordered set and second element is a tuple :
    ( (p0, p_1, ..., p_n), (i_0, i_1, ..., i_n) }.

    The former is more "accurate" as the equivalence of maps can be directly determined.
    But it requires more object lookups when looking for map values.

    The latter is less "accurate" in the sense that two distinct maps can be equivalent,
    e.g.: ( (1, 2, 3), (4, 5, 6) ) ~ ( (3, 2, 1), (6, 5, 4) ).

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractMap, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractMap, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_inline_map()

    def __str__(self):
        return self.represent_as_inline_map()

    _HASH_SEED: int = 15749856293511400051  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def codomain(self) -> AbstractTuple:
        if isinstance(self.immediate_subtrees[1], AbstractTuple):
            # the codomain is already of type AbstractTuple, no need to re-instantiate it.
            codomain: AbstractTuple = self.immediate_subtrees[1]
            return codomain
        else:
            # the codomain is not of type AbstractTuple, it must be re-instantiated.
            return AbstractTuple.from_lrpt(self.immediate_subtrees[1])

    @functools.cached_property
    def domain(self) -> AbstractOrderedSet:
        if isinstance(self.immediate_subtrees[1], AbstractOrderedSet):
            # the codomain is already of type AbstractOrderedSet, no need to re-instantiate it.
            domain: AbstractOrderedSet = self.immediate_subtrees[0]
            return domain
        else:
            # the codomain is not of type AbstractTuple, it must be re-instantiated.
            return AbstractOrderedSet.from_lrpt(self.immediate_subtrees[0])

    @classmethod
    def from_domain_and_codomain(cls,
                                 domain: lrptl.FlexibleLabeledRootedPlaneTree,
                                 codomain: lrptl.FlexibleLabeledRootedPlaneTree,
                                 n: int = 0
                                 ) -> AbstractMap:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_immediate_subtrees(n=n, s=(domain, codomain,))

    def get_value(self, x: FlexibleSyntacticStructure) -> SyntacticStructure:
        r"""If this LRPT is an abstract-map, returns the image `x` under this map.

        :param x: a preimage element.
        :return: the image of `t` under this map.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        if not self.domain.has_element(x):
            raise util.PunctiliousException("`x` is not an element of the domain.", x=x, domain=domain)
        else:
            i: int = self.domain.get_element_index(x)
            return self.codomain.get_element_by_index(i)

    def has_domain_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this abstract map domain, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        return self.domain.has_element(x)

    def is_abstract_map_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract map equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is abstract map equivalent to `y` if and only if:

        - :math:`x` and :math:`y` are abstract maps,
        - the set of ordered pairs of :math:`x` is abstract set equivalent
          to the set of ordered pairs of :math:`y`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        x: lrptl.LRPT = lrptl.LRPT.from_any(x)
        if not AbstractMap.is_well_formed(x, raise_exception_if_false=False):
            return False
        else:
            x: AbstractMap = AbstractMap.from_any(x)
            if not self.domain.is_abstract_ordered_set_equivalent_to(x.domain):
                return False
            if not self.codomain.is_abstract_tuple_equivalent_to(x.codomain):
                return False
            return True

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure,
            raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is well-formed,
        that if it complies with all constraints applicable to this syntactic structure.

        If `True`, :meth:`SyntacticStructure.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if isinstance(o, AbstractMap):
            return True
        lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
        if lrpt.degree < 2:
            if raise_exception_if_false:
                raise util.PunctiliousException("deg(T) < 2.", deg_t=lrpt.degree,
                                                t=lrpt)
            else:
                return False
        if not AbstractOrderedSet.is_well_formed(lrpt.immediate_subtrees[0]):
            if raise_exception_if_false:
                raise util.PunctiliousException("First subtree is not a well-formed abstract ordered set.",
                                                first_subtree=lrpt.immediate_subtrees[0])
            else:
                return False
        if not AbstractTuple.is_well_formed(lrpt.immediate_subtrees[1]):
            if raise_exception_if_false:
                raise util.PunctiliousException("Second subtree is not a well-formed abstract ordered set.",
                                                second_subtree=lrpt.immediate_subtrees[1])
            else:
                return False
        domain: AbstractOrderedSet = AbstractOrderedSet(lrpt.immediate_subtrees[0])
        codomain: AbstractTuple = AbstractTuple(lrpt.immediate_subtrees[1])
        if domain.cardinality != codomain.cardinality:
            if raise_exception_if_false:
                raise util.PunctiliousException(
                    "The cardinality of the domain is not equal to the cardinality of the codomain.",
                    domain=domain, codomain=codomain)
            else:
                return False
        # The syntactic structure satisfies all constraints.
        return True

    @functools.cached_property
    def ordered_pairs(self) -> AbstractSet:
        r"""Returns the set of ordered pairs that constitutes this abstract map.

        :return: A set of ordered pairs.
        """
        pairs: tuple[AbstractOrderedPair, ...] = ()
        for preimage, image in zip(self.domain.elements, self.codomain.elements):
            pair: AbstractOrderedPair = AbstractOrderedPair.from_first_and_second_elements(preimage, image)
            pairs = pairs + (pair,)
        return AbstractSet.from_elements(*pairs)

    def represent_as_inline_map(self) -> str:
        r"""Returns a string representation of the LRPT using map notation.

        :return: A string representation of this LRPT.

        """
        output = f"{{ "
        first = True
        for preimage, image in zip(
                self.domain.elements,
                self.codomain.elements):
            if not first:
                output = f"{output}, "
            output = f"{output}{preimage} ⟼ {image}"
            first = False
        output = f"{output} }}"

        return output


class AbstractSet(SyntacticStructure):
    r"""An abstract set.

    Definition
    ------------

    An `abstract set` is a syntactic structure that models a finite (computable) set defined by extension.

    Given any LRPT :math:`T`,
    its `abstract set` is the set :math:`{t_0, t_1, \cdots, t_n}`
    where :math:`t_i` denotes the immediate and unique sub-LRPTs of :math:`T`.

    Note
    ------

    The main element of the LRPT is not an information of the abstract set, i.e.: it is dropped.

    The order of immediate sub-LRPTs in the LRPT is not an information of the abstract set, i.e.: it is dropped.

    Note
    -----------

    Every LRPT is an abstract set.

    Note
    ----------

    Every LRPT of degree 0 is the empty set.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractSet, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractSet, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_set()

    def __str__(self):
        return self.represent_as_set()

    _HASH_SEED: int = 687807374550534646  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this abstract set.

        Note
        ______

        This is equal to the number of unique immediate sub-LRPTs
        in the LRPT of this syntactic structure.

        This is equivalent to the degree of the LRPT
        if its immediate sub-LRPTs are unique.

        :return: an integer.
        """
        return len(self.elements)

    @functools.cached_property
    def elements(self) -> tuple[SyntacticStructure, ...]:
        r"""Returns the elements of this abstract set.

        Note
        ______

        This is equivalent to the unique and immediate subtrees of the LRPT.

        Note
        ------

        Even though sets are not ordered, by convention the elements of an abstract set
        are ordered by LRPT canonical order, facilitating equivalence checking.

        :return: The elements of the set.
        """
        unique_elements: tuple[SyntacticStructure, ...] = ()
        for sub_ss in self.immediate_sub_syntactic_structures:
            if sub_ss not in unique_elements:
                unique_elements = unique_elements + (sub_ss,)
        # by convention, returns the elements in canonical LRPT order,
        # this facilitates equivalence checking.
        unique_elements = tuple(sorted(unique_elements))
        return unique_elements

    @classmethod
    def from_any(cls, x: FlexibleAbstractSet) -> AbstractSet:
        if isinstance(x, AbstractSet):
            return x
        elif isinstance(x, tuple) and not isinstance(x, lrptl.LRPT):
            # This is a "pure" python tuple,
            # i.e. it is not an LRPT that inherits from python tuple.
            # This signature is interpreted the elements of the abstract set.
            return cls.from_elements(*x)
        else:
            # Fallback to the original LRPT from_any() method.
            return cls.from_lrpt(x)

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> AbstractSet:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        elements = tuple(SyntacticStructure.from_any(x) for x in elements)
        return cls.from_immediate_subtrees(n=n, s=elements)

    def has_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this set, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        return self.has_immediate_subtree(x)

    def is_abstract_set_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract set equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is abstract set equivalent to `y` if and only if:

        - every immediate sub-LRPT of :math:`x` is an immediate sub-LRPT of :math:`y`,
        - every immediate sub-LRPT of :math:`y` is an immediate sub-LRPT of :math:`z`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to abstract set is possible because abstract sets have no constraints.
        x: AbstractSet = AbstractSet.from_any(x)

        # direct comparison of elements is possible because they are canonically ordered by convention.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls, o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed abstract set.

        But because every LRPT is an abstract set, this method always returns `True`.

        If `True`, :meth:`AbstractSet.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if not isinstance(o, SyntacticStructure):
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
        return True

    def represent_as_set(self) -> str:
        r"""Returns a string representation of the LRPT using map notation.

        :return: A string representation of this LRPT.

        """
        output = f"{{ "
        first = True
        for element in self.elements:
            if not first:
                output = f"{output}, "
            output = f"{output}{element}"
            first = False
        output = f"{output} }}"

        return output


class AbstractTuple(SyntacticStructure):
    r"""An abstract tuple.

    Definition
    ------------

    An `abstract tuple` is a syntactic structure that models a finite (computable) tuple defined by extension.

    Given any LRPT :math:`T`,
    its `abstract tuple` is the tuple :math:`{t_0, t_1, \cdots, t_n}`
    where :math:`t_i` denotes the immediate sub-LRPTs of :math:`T`.

    Note
    ------

    The main element of the LRPT is not an information of the abstract set, i.e.: it is dropped.

    Note
    -----------

    Every LRPT is an abstract tuple.

    Note
    ----------

    Every LRPT of degree 0 is the empty tuple.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractTuple, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractTuple, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_tuple()

    def __str__(self):
        return self.represent_as_tuple()

    _HASH_SEED: int = 12503318805270547491  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this abstract tuple.

        Note
        ______

        This is equivalent to the degree of the LRPT.

        :return: an integer.
        """
        return len(self.elements)

    @functools.cached_property
    def elements(self) -> tuple[SyntacticStructure, ...]:
        r"""Returns the elements of this abstract tuple, preserving order.

        Note
        ______

        This is equivalent to the immediate subtrees of the LRPT,
        typed as syntactic structures.

        :return: The elements of the tuple.
        """
        return self.immediate_sub_syntactic_structures

    @classmethod
    def from_any(cls, x: FlexibleAbstractTuple) -> AbstractTuple:
        if isinstance(x, AbstractTuple):
            return x
        elif isinstance(x, tuple) and not isinstance(x, lrptl.LRPT):
            # This is a "pure" python tuple,
            # i.e. it is not an LRPT that inherits from python tuple.
            # This signature is interpreted the elements of the abstract tuple.
            return cls.from_elements(*x)
        else:
            # Fallback to the original LRPT from_any() method.
            return cls.from_lrpt(x)

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> AbstractTuple:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        elements = tuple(SyntacticStructure.from_any(x) for x in elements)
        return cls.from_immediate_subtrees(n=n, s=elements)

    def get_element_by_index(self, i: int) -> lrptl.LabeledRootedPlaneTree:
        if i < 0 or i >= self.cardinality:
            raise util.PunctiliousException("Index `i` is out of range of this abstract tuple `t`.", i=i,
                                            degree_of_t=self.degree, t=self)
        return self.elements[i]

    def has_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this tuple, `False` otherwise.

        Definition
        ------------

        :math:`x` is an element of abstract tuple :math:`S` if and only if there exists
        an immediate sub-LRPT :math:`y` of :math:`S` such that :math:`x \quad \sim_{LRPT} \quad y`.

        Note
        ------

        An element `x` may appear multiple times in an abstract tuple.

        :param x: An object.
        :return: `True` or `False`
        """
        return self.has_immediate_subtree(x)

    def is_abstract_tuple_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract tuple equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is abstract tuple equivalent to `y` if and only if:

        - the degree of :math:`x` is equal to the degree of :math:`y`,
        - :math:`x_i` is LRPT equivalent to :math:`x_i` for :math:`0 <= i < \mathrm{deg}(x)`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to abstract tuple is possible because abstract tuples have no constraints.
        x: AbstractTuple = AbstractTuple.from_any(x)

        # direct comparison of elements is possible because they are canonically ordered by convention.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed abstract tuple.

        But because every LRPT is an abstract tuple, this method always returns `True`.

        If `True`, :meth:`AbstractTuple.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if not isinstance(o, SyntacticStructure):
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
        return True

    def represent_as_tuple(self) -> str:
        r"""Returns a string representation of the LRPT using map notation.

        :return: A string representation of this LRPT.

        """
        output = f"( "
        first = True
        for element in self.elements:
            if not first:
                output = f"{output}, "
            output = f"{output}{element}"
            first = False
        output = f"{output} )"

        return output


class AbstractOrderedPair(AbstractTuple):
    r"""An abstract ordered pair.

    Definition
    ------------

    An `abstract ordered pair` is a syntactic structure that models an ordered pair.

    Given any LRPT :math:`T` of degree >= 2,
    its `abstract ordered pair` is the tuple :math:`(t_0, t_1)`
    where :math:`t_i` denotes the :math:`i`-th immediate sub-LRPT of :math:`T`.

    Note
    ------

    The main element of the LRPT is not an information of the abstract ordered pair, i.e.: it is dropped.

    Note
    -----------

    Every LRPT of degree >= 2 is an abstract ordered pair.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractOrderedPair, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractOrderedPair, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    _HASH_SEED: int = 12810223144789917182  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def first_element(self) -> SyntacticStructure:
        return self.elements[0]

    @classmethod
    def from_first_and_second_elements(cls,
                                       first_element: FlexibleSyntacticStructure,
                                       second_element: FlexibleSyntacticStructure,
                                       n: int | None = None,
                                       ) -> AbstractOrderedPair:
        r"""Returns the abstract ordered pair :math:`(x, y)`
        where :math:`x` is the first element,
        and :math:`y` is the second element.

        :param first_element: A syntactic structure.
        :param second_element: A syntactic structure.
        :param n: (conditional) The main element of the LRPT.
        :return: An abstract ordered pair.
        """
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        first_element: SyntacticStructure = SyntacticStructure.from_any(first_element)
        second_element: SyntacticStructure = SyntacticStructure.from_any(second_element)
        return cls.from_immediate_subtrees(n=n, s=(first_element, second_element,))

    def is_abstract_ordered_pair_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract ordered pair equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be abstract ordered pairs.
        :math:`x` is abstract ordered pair equivalent to `y` if and only if:

        - The first element of :math:`x` is LRPT equivalent to the first element of :math:`y`.
        - The second element of :math:`x` is LRPT equivalent to the second element of :math:`y`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        x: SyntacticStructure = SyntacticStructure.from_any(x)
        if not AbstractOrderedPair.is_well_formed(x):
            return False
        else:
            x: AbstractOrderedPair = AbstractOrderedPair.from_any(x)
            if not x.first_element.is_labeled_rooted_plane_tree_equivalent_to(self.first_element):
                return False
            if not x.second_element.is_labeled_rooted_plane_tree_equivalent_to(self.second_element):
                return False
            return True

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed abstract ordered pair.

        If `True`, :meth:`AbstractOrderedPair.from_any` can be safely called on `o`.

        :param o: A syntactic structure.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        o: SyntacticStructure = SyntacticStructure.from_any(o)
        if o.degree >= 2:
            return True
        else:
            return False

    @functools.cached_property
    def second_element(self) -> SyntacticStructure:
        return self.elements[1]


class AbstractInferenceRule(SyntacticStructure):
    r"""An abstract inference rule.

    Definition
    ------------

    An `abstract inference rule` is a syntactic structure that models an inference rule of the form:

    Given :math:`x_1, x_2, \cdots, x_n` denoted as the variables.

    Given theorems :math:`\Psi_1, \Psi_2, \cdots, \Psi_m` denoted as the premises (possibly containing instances of the above variables):

    Theorem :math:`\Phi` denoted as the conclusion follows (possibly containing instances of the above variables).

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractInferenceRule, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractInferenceRule, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    _HASH_SEED: int = 166751588910771296  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def from_components(cls,
                        variables: FlexibleAbstractSet,
                        premises: FlexibleAbstractSet,
                        conclusion: lrptl.FlexibleLabeledRootedPlaneTree,
                        n: int = 0
                        ) -> AbstractInferenceRule:
        variables = AbstractSet.from_elements(*variables)
        premises = AbstractSet.from_elements(*premises)
        conclusion = lrptl.LRPT.from_any(conclusion)
        n: int = int(n)
        return cls.from_immediate_subtrees(n=n, s=(variables, premises, conclusion,))


# Flexible types to facilitate data validation

FlexibleSyntacticStructure = lrptl.FlexibleLabeledRootedPlaneTree
FlexibleAbstractSet = typing.Union[
    AbstractSet,
    LabeledRootedPlaneTree,  # already typed as LRPT.
    tuple[rptl.FlexibleRootedPlaneTree, ...],  # the elements of the abstract set.
    None  # the empty abstract set.
]
FlexibleAbstractOrderedSet = typing.Union[
    AbstractOrderedSet,
    LabeledRootedPlaneTree,  # already typed as LRPT.
    tuple[rptl.FlexibleRootedPlaneTree, ...],  # the elements of the abstract set.
    None  # the empty abstract set.
]
FlexibleAbstractTuple = typing.Union[
    AbstractTuple,
    LabeledRootedPlaneTree,  # already typed as LRPT.
    tuple[rptl.FlexibleRootedPlaneTree, ...],  # the elements of the abstract set.
    None  # the empty abstract set.
]

# Aliases

AIR = AbstractInferenceRule  # An alias for :class:`AbstractInferenceRule`.
AM = AbstractMap  # An alias for :class:`AbstractMap`.
AOS = AbstractOrderedSet  # An alias for :class:`AbstractOrderedSet`.
AS = AbstractSet  # An alias for :class:`AbstractSet`.
AT = AbstractTuple  # An alias for :class:`AbstractTuple`.
SR = SyntacticStructure  # An alias for :class:`SyntacticStructure`.
