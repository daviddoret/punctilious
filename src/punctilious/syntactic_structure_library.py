r"""

"""
from __future__ import annotations

import typing

import functools

import punctilious.util as util
import punctilious.natural_number_0_sequence_library as nn0sl
import punctilious.rooted_plane_tree_library as rptl
import punctilious.labeled_rooted_plane_tree_library as lrptl
from punctilious.labeled_rooted_plane_tree_library import LabeledRootedPlaneTree


class SyntacticStructure(lrptl.LabeledRootedPlaneTree):
    r"""A syntactic structure.

    Definition
    ------------

    A `syntactic structure` is an LRPT,
    possibly satisfying a set of defined constraints,
    that represents a mathematical object,
    but that is independent of the actual symbols used to represent it.

    Implementation
    ---------------

    Syntactic structure python classes inherit from LRPT.
    Given an LRPT `x` that satisfies the required constraints,
    the corresponding syntactic structure can be re-instantiated
    as a syntactic structure using SomeSyntacticStructure.from_lrpt(x).
    This will create a new object typed as SomeSyntacticStructure,
    giving access to the properties and methods of SomeSyntacticStructure.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticStructure, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        lrpt = super(SyntacticStructure, cls).__new__(cls, rpt, sequence)
        return lrpt

    _HASH_SEED: int = 10428185094283398729  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def from_any(
            cls,
            o: FlexibleSyntacticStructure) -> SyntacticStructure:
        if isinstance(o, SyntacticStructure):
            return o
        elif isinstance(o, lrptl.LabeledRootedPlaneTree):
            return cls.from_lrpt(x=o)
        else:
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
            return cls.from_lrpt(x=lrpt)

    @classmethod
    def from_lrpt(cls, x: lrptl.FlexibleLabeledRootedPlaneTree):
        return cls(rpt=x.t, sequence=x.s)

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is well-formed.

        Definition
        ------------
        A syntactic structure or LRPT is well-formed
        if it complies with all constraints applicable to that syntactic structure.

        Note
        -----
        This method must be overridden in every python subclass
        that imposes a set of constraints.

        If `True`, :meth:`SyntacticStructure.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if not isinstance(o, SyntacticStructure):
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
        return True


class AbstractOrderedSet(SyntacticStructure):
    r"""An abstract ordered set.

    Definition
    ------------

    An `abstract ordered set` is a syntactic structure that models a finite (computable) ordered set defined by extension.

    Given LRPT :math:`T` with sub-LRPTs :math:`t_0, t_1, \cdots, t_n`,
    its `abstract ordered set` is the ordered set :math:`(s_0, s_1, \cdots, s_m)`
    where :math:`s_i` denotes the :math:`i`-th *unique* immediate sub-LRPTs of :math:`T`, preserving order.

    Sample
    --------
    Given :math:`T = 0(3, 1, 1, 1, 2)`, the corresponding abstract ordered set is :math:`(3, 1, 2)`.

    Note
    ------

    The main element of the LRPT is not an information of the abstract ordered set, i.e.: it is dropped.

    Note
    -----------

    Every LRPT is an abstract ordered set.

    Note
    ----------

    Every LRPT of degree 0 is the empty ordered set.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractOrderedSet, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractOrderedSet, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    _HASH_SEED: int = 16508528480418369971  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this abstract ordered set.

        Note
        ______

        This is equal to the number of unique immediate sub-LRPTs
        in the LRPT of this syntactic structure.

        This is equivalent to the degree of the LRPT
        if its immediate sub-LRPTs are unique.

        :return: an integer.
        """
        return len(self.elements)

    @functools.cached_property
    def elements(self) -> tuple[lrptl.LabeledRootedPlaneTree, ...]:
        r"""Returns the elements of this abstract ordered set.

        Note
        ______

        This is equivalent to the unique and immediate subtrees of the LRPT, preserving order.

        :return: The elements of the ordered set, in order.
        """
        unique_elements: tuple[lrptl.LabeledRootedPlaneTree, ...] = ()
        for sub_lrpt in self.iterate_immediate_subtrees():
            if sub_lrpt not in unique_elements:
                unique_elements = unique_elements + (sub_lrpt,)
        return unique_elements

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> AbstractOrderedSet:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_immediate_subtrees(n=n, s=elements)

    def get_element_by_index(self, i: int) -> lrptl.LabeledRootedPlaneTree:
        if not 0 < i < self.cardinality:
            raise util.PunctiliousException("Index `i` is out of range of this abstract ordered set.")
        return self.elements[i]

    def get_element_index(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> int:
        if not self.has_element(x):
            raise util.PunctiliousException("`x` is not an element of this abstract ordered set.", x=x, poset=self)
        return self.elements.index(x)

    def has_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this set, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        x: lrptl.LabeledRootedPlaneTree = LabeledRootedPlaneTree.from_any(x)
        return self.has_immediate_subtree(x)

    def is_abstract_ordered_set_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract ordered set equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is abstract set equivalent to `y` if and only if:

        - every immediate sub-LRPT of :math:`x` is an immediate sub-LRPT of :math:`y`,
        - every immediate sub-LRPT of :math:`y` is an immediate sub-LRPT of :math:`x`,
        - the order of the first occurrence of every sub-LRPT in :math:`x`
          is equal to the order of its first occurrence in :math:`y`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to abstract set is possible because abstract ordered sets have no constraints.
        x: AbstractOrderedSet = AbstractOrderedSet.from_any(x)

        # direct comparison of elements is possible because order is considered.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed abstract ordered set.

        But because every LRPT is an abstract ordered set, this method always returns `True`.

        If `True`, :meth:`AbstractOrderedSet.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        ss: SyntacticStructure = cls.from_any(o)
        return True


class AbstractMap(SyntacticStructure):
    r"""An abstract map.

    Definition
    ------------

    An `abstract map` is a syntactic structure that models a finite (computable) map defined by extension.

    Given any LRPT :math:`T` with the following constraints:
     - its degree is at least 2,
     - its first sub-LRPT is an abstract ordered set of cardinality :math:`n`, denoted as the domain,
     - its second sub-LRPT is an abstract tuple of cardinality :math:`n`, denoted as the codomain,
     - the cardinality of the domain is equal to the cardinality of the codomain,
    its `abstract map` is the map that to the :math:`i`-th element of the domain,
    maps the :math:`i`-th element of the codomain,
    and that is otherwise undefined.

    Note
    ------

    The main element of the LRPT and the main element of the first two immediate sub-LRPTs are not an information of the abstract map, i.e.: it is dropped.
    Any immediate sub-LRPT of the LRPT beyond 2 is not an information of the abstract map, i.e. it is dropped.

    Note
    -----------

    Every LRPT of degree > 1 is an abstract map.

    Note
    ----------

    If the domain is the empty ordered set, it is the empty map.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractMap, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractMap, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    _HASH_SEED: int = 15749856293511400051  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def codomain(self) -> AbstractTuple:
        if isinstance(self.immediate_subtrees[1], AbstractTuple):
            # the codomain is already of type AbstractTuple, no need to re-instantiate it.
            codomain: AbstractTuple = self.immediate_subtrees[1]
            return codomain
        else:
            # the codomain is not of type AbstractTuple, it must be re-instantiated.
            return AbstractTuple.from_lrpt(self.immediate_subtrees[1])

    @functools.cached_property
    def domain(self) -> AbstractOrderedSet:
        if isinstance(self.immediate_subtrees[1], AbstractOrderedSet):
            # the codomain is already of type AbstractOrderedSet, no need to re-instantiate it.
            domain: AbstractOrderedSet = self.immediate_subtrees[0]
            return domain
        else:
            # the codomain is not of type AbstractTuple, it must be re-instantiated.
            return AbstractOrderedSet.from_lrpt(self.immediate_subtrees[0])

    @classmethod
    def from_domain_and_codomain(cls,
                                 domain: lrptl.FlexibleLabeledRootedPlaneTree,
                                 codomain: lrptl.FlexibleLabeledRootedPlaneTree,
                                 n: int = 0
                                 ) -> AbstractMap:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_immediate_subtrees(n=n, s=(domain, codomain,))

    def get_value(self, x: FlexibleSyntacticStructure) -> SyntacticStructure:
        r"""If this LRPT is an abstract-map, returns the image `x` under this map.

        :param x: a preimage element.
        :return: the image of `t` under this map.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        if not self.domain.has_element(x):
            raise util.PunctiliousException("`x` is not an element of the domain.", x=x, domain=domain)
        else:
            i: int = self.domain.get_element_index(x)
            return self.codomain.get_element_by_index(i)

    def has_domain_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this abstract map domain, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        return self.domain.has_element(x)

    def is_abstract_map_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract map equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is abstract map equivalent to `y` if and only if:

        - :math:`x` and :math:`y` are abstract maps,
        - the domain of :math:`x` is abstract ordered set equivalent to the domain of :math:`y`,
        - the codomain of :math:`x` is abstract tuple equivalent to the codomain of :math:`y`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        x: lrptl.LRPT = lrptl.LRPT.from_any(x)
        if not AbstractMap.is_well_formed(x, raise_exception_if_false=False):
            return False
        else:
            x: AbstractMap = AbstractMap.from_any(x)
            if not self.domain.is_abstract_ordered_set_equivalent_to(x.domain):
                return False
            if not self.codomain.is_abstract_tuple_equivalent_to(x.codomain):
                return False
            return True

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure,
            raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is well-formed,
        that if it complies with all constraints applicable to this syntactic structure.

        If `True`, :meth:`SyntacticStructure.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if isinstance(o, AbstractMap):
            return True
        lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
        if lrpt.degree < 2:
            if raise_exception_if_false:
                raise util.PunctiliousException("deg(T) < 2.", deg_t=lrpt.degree,
                                                t=lrpt)
            else:
                return False
        if not AbstractOrderedSet.is_well_formed(lrpt.immediate_subtrees[0]):
            if raise_exception_if_false:
                raise util.PunctiliousException("First subtree is not a well-formed abstract ordered set.",
                                                first_subtree=lrpt.immediate_subtrees[0])
            else:
                return False
        if not AbstractTuple.is_well_formed(lrpt.immediate_subtrees[1]):
            if raise_exception_if_false:
                raise util.PunctiliousException("Second subtree is not a well-formed abstract ordered set.",
                                                second_subtree=lrpt.immediate_subtrees[1])
            else:
                return False
        domain: AbstractOrderedSet = AbstractOrderedSet(lrpt.immediate_subtrees[0])
        codomain: AbstractTuple = AbstractTuple(lrpt.immediate_subtrees[1])
        if domain.cardinality != codomain.cardinality:
            if raise_exception_if_false:
                raise util.PunctiliousException(
                    "The cardinality of the domain is not equal to the cardinality of the codomain.",
                    domain=domain, codomain=codomain)
            else:
                return False
        # The syntactic structure satisfies all constraints.
        return True


class AbstractSet(SyntacticStructure):
    r"""An abstract set.

    Definition
    ------------

    An `abstract set` is a syntactic structure that models a finite (computable) set defined by extension.

    Given any LRPT :math:`T`,
    its `abstract set` is the set :math:`{t_0, t_1, \cdots, t_n}`
    where :math:`t_i` denotes the immediate and unique sub-LRPTs of :math:`T`.

    Note
    ------

    The main element of the LRPT is not an information of the abstract set, i.e.: it is dropped.

    The order of immediate sub-LRPTs in the LRPT is not an information of the abstract set, i.e.: it is dropped.

    Note
    -----------

    Every LRPT is an abstract set.

    Note
    ----------

    Every LRPT of degree 0 is the empty set.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractSet, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractSet, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    _HASH_SEED: int = 687807374550534646  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this abstract set.

        Note
        ______

        This is equal to the number of unique immediate sub-LRPTs
        in the LRPT of this syntactic structure.

        This is equivalent to the degree of the LRPT
        if its immediate sub-LRPTs are unique.

        :return: an integer.
        """
        return len(self.elements)

    @functools.cached_property
    def elements(self) -> tuple[lrptl.LabeledRootedPlaneTree, ...]:
        r"""Returns the elements of this abstract set.

        Note
        ______

        This is equivalent to the unique and immediate subtrees of the LRPT.

        Note
        ------

        Even though sets are not ordered, by convention the elements of an abstract set
        are ordered by LRPT canonical order, facilitating equivalence checking.

        :return: The elements of the set.
        """
        unique_elements: tuple[lrptl.LabeledRootedPlaneTree, ...] = ()
        for sub_lrpt in self.iterate_immediate_subtrees():
            if sub_lrpt not in unique_elements:
                unique_elements = unique_elements + (sub_lrpt,)
        # by convention, returns the elements in canonical lrpt order
        unique_elements = tuple(sorted(unique_elements))
        return unique_elements

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> AbstractSet:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_immediate_subtrees(n=n, s=elements)

    def has_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this set, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        return self.has_immediate_subtree(x)

    def is_abstract_set_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract set equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is abstract set equivalent to `y` if and only if:

        - every immediate sub-LRPT of :math:`x` is an immediate sub-LRPT of :math:`y`,
        - every immediate sub-LRPT of :math:`y` is an immediate sub-LRPT of :math:`z`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to abstract set is possible because abstract sets have no constraints.
        x: AbstractSet = AbstractSet.from_any(x)

        # direct comparison of elements is possible because they are canonically ordered by convention.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls, o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed abstract set.

        But because every LRPT is an abstract set, this method always returns `True`.

        If `True`, :meth:`AbstractSet.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if not isinstance(o, SyntacticStructure):
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
        return True


class AbstractTuple(SyntacticStructure):
    r"""An abstract tuple.

    Definition
    ------------

    An `abstract tuple` is a syntactic structure that models a finite (computable) tuple defined by extension.

    Given any LRPT :math:`T`,
    its `abstract tuple` is the tuple :math:`{t_0, t_1, \cdots, t_n}`
    where :math:`t_i` denotes the immediate sub-LRPTs of :math:`T`.

    Note
    ------

    The main element of the LRPT is not an information of the abstract set, i.e.: it is dropped.

    Note
    -----------

    Every LRPT is an abstract tuple.

    Note
    ----------

    Every LRPT of degree 0 is the empty tuple.

    """

    def __init__(self,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(AbstractTuple, self).__init__(rpt, sequence)

    def __new__(cls,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(AbstractTuple, cls).__new__(cls, rpt, sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    _HASH_SEED: int = 12503318805270547491  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this abstract tuple.

        Note
        ______

        This is equivalent to the degree of the LRPT.

        :return: an integer.
        """
        return len(self.elements)

    @functools.cached_property
    def elements(self) -> tuple[lrptl.LabeledRootedPlaneTree, ...]:
        r"""Returns the elements of this abstract tuple, preserving order.

        Note
        ______

        This is equivalent to the immediate subtrees of the LRPT.

        :return: The elements of the tuple.
        """
        return self.immediate_subtrees

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> AbstractTuple:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_immediate_subtrees(n=n, s=elements)

    def get_element_by_index(self, i: int) -> lrptl.LabeledRootedPlaneTree:
        if i < 0 or i >= self.cardinality:
            raise util.PunctiliousException("Index `i` is out of range of this abstract tuple `t`.", i=i,
                                            degree_of_t=self.degree, t=self)
        return self.elements[i]

    def has_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this tuple, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        return self.has_immediate_subtree(x)

    def is_abstract_tuple_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is abstract tuple equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is abstract tuple equivalent to `y` if and only if:

        - the degree of :math:`x` is equal to the degree of :math:`y`,
        - :math:`x_i` is LRPT equivalent to :math:`x_i` for :math:`0 <= i < \mathrm{deg}(x)`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to abstract set is possible because abstract sets have no constraints.
        x: AbstractSet = AbstractSet.from_any(x)

        # direct comparison of elements is possible because they are canonically ordered by convention.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed abstract tuple.

        But because every LRPT is an abstract tuple, this method always returns `True`.

        If `True`, :meth:`AbstractTuple.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if not isinstance(o, SyntacticStructure):
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
        return True


# Flexible types to facilitate data validation

FlexibleSyntacticStructure = typing.Union[
    SyntacticStructure, lrptl.FlexibleLabeledRootedPlaneTree]

# Aliases

AM = AbstractMap  # An alias for :class:`AbstractMap`.
AOS = AbstractOrderedSet  # An alias for :class:`AbstractOrderedSet`.
AS = AbstractSet  # An alias for :class:`AbstractSet`.
AT = AbstractTuple  # An alias for :class:`AbstractTuple`.
SR = SyntacticStructure  # An alias for :class:`SyntacticStructure`.
