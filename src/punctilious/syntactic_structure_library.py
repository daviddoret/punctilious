r"""The syntactic structure layer enriches the LRPT layer by promoting LRPTs to syntactic structures.
By imposing constraints on LRPTs, syntactic structures enable the modeling of
finite proto- or foundational mathematical objects, including:

- syntactic inference rules,
- syntactic maps,
- syntactic ordered pairs,
- syntactic ordered sets,
- syntactic sets,
- syntactic tuples.

... and specialized algorithms.

These foundational objects enable the construction of a proto- or foundational formal language,
which then enables the creation of arbitrary formal languages.

"""
from __future__ import annotations

# import collections
import typing

import functools

import punctilious.util as util
import punctilious.natural_number_0_sequence_library as nn0sl
import punctilious.rooted_plane_tree_library as rptl
import punctilious.labeled_rooted_plane_tree_library as lrptl


class SyntacticStructure(lrptl.LabeledRootedPlaneTree):
    r"""A syntactic structure.

    Definition
    ------------

    A `syntactic structure` is an LRPT,
    possibly satisfying a set of defined constraints,
    that represents a mathematical object,
    but that is independent of the actual symbols used to represent it.

    Implementation
    ---------------

    Syntactic structure python classes inherit from LRPT.
    Given an LRPT `x` that satisfies the required constraints,
    the corresponding syntactic structure can be re-instantiated
    as a syntactic structure using SomeSyntacticStructure.from_lrpt(x).
    This will create a new object typed as SomeSyntacticStructure,
    giving access to the properties and methods of SomeSyntacticStructure.

    """

    def __eq__(self, other):
        r"""Returns `True` if `self` is `syntactic structure equivalent` to `other`, `False` otherwise.

        Note
        -----
        Python equality is less restrictive than syntactic structure equivalence.
        In effect, if `other` is not implicitly convertible to type `SyntacticStructure`,
        the result will be `False` instead of raising an exception.

        :param other: Anything
        :return: `True` or `False`.
        """
        try:
            other: SyntacticStructure = SyntacticStructure.from_any(other)
            return self.is_syntactic_structure_equivalent_to(other)
        except util.PunctiliousException:
            return False

    def __init__(self,
                 *args: SyntacticStructure,
                 n: int | None = None,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticStructure, self).__init__(*args, n=n, rpt=rpt, sequence=sequence)

    def __new__(cls,
                *args: SyntacticStructure,
                n: int | None = None,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        lrpt = super(SyntacticStructure, cls).__new__(cls, *args, n=n, rpt=rpt, sequence=sequence)
        return lrpt

    _HASH_SEED: int = 10428185094283398729  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def compare(cls, x: FlexibleSyntacticStructure, y: FlexibleSyntacticStructure) -> int:
        r"""Returns -1 if :math:`x < y`, 0 if :math:`x = y`, 1 if :math:`x > y` following canonical order.

        Note
        -----
        The default sorting of syntactic structures is based on their python hash value.
        This design decision is only motivated by the need to have a very efficient
        sorting algorithm, especially for syntactic set elements.
        In the future, if a new order sequence is found that can both
        provide efficient sorting, and provide an efficient unranking function,
        and is a bijection with the natural numbers, then this method can be replaced.

        Note
        -----
        This method is used in conjunction with `functools.cmp_to_key`
        to implement the :meth:`FlexibleSyntacticStructure.sort` method.

        :param x: A syntactic structure.
        :param y: A syntactic structure.
        :return: -1, 0, or 1.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        y: SyntacticStructure = SyntacticStructure.from_any(y)
        if lrptl.PythonHashOrder.relates(x, y):
            return -1
        elif lrptl.PythonHashOrder.relates(y, x):
            return 1
        else:
            return 0

    @classmethod
    def drop_duplicates(cls, *args) -> tuple[SyntacticStructure, ...]:
        r"""Returns unique elements, dropping duplicates and preserving order.

        :param args: A python tuple of syntactic structures.
        :return: A python tuple of unique syntactic structures.
        """
        args: tuple[SyntacticStructure, ...] = tuple(SyntacticStructure.from_any(x) for x in args)
        t: tuple[SyntacticStructure, ...] = tuple()
        for x in args:
            if x not in t:
                t += (x,)
        return t

    @classmethod
    def from_any(
            cls,
            o: FlexibleSyntacticStructure) -> SyntacticStructure:
        if isinstance(o, SyntacticStructure):
            return o
        elif isinstance(o, lrptl.LabeledRootedPlaneTree):
            return cls.from_lrpt(x=o)
        else:
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(o)
            return cls.from_lrpt(x=lrpt)

    @classmethod
    def from_lrpt(cls, x: lrptl.FlexibleLabeledRootedPlaneTree):
        return cls(n=None, rpt=x.t, sequence=x.s)

    def has_sub_syntactic_structure(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Returns `True` if `x` is a sub syntactic structure of `self`, otherwise `False`."""
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        return self.has_immediate_subtree(x)

    @functools.cached_property
    def immediate_sub_syntactic_structures(self) -> tuple[SyntacticStructure, ...]:
        return tuple(SyntacticStructure.from_lrpt(lrpt) for lrpt in self.immediate_subtrees)

    def is_syntactic_structure_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""

        Syntactic structure equivalence is synonym with labeled rooted plane tree equivalence.

        :param x:
        :return:
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        return self.is_labeled_rooted_plane_tree_equivalent_to(x)

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is well-formed.

        Definition
        ------------
        A syntactic structure or LRPT is well-formed
        if it complies with all constraints applicable to that syntactic structure.

        Note
        -----
        This method must be overridden in every python subclass
        that imposes a set of constraints.

        If `True`, :meth:`SyntacticStructure.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        cls.from_any(o)
        return True

    @util.readonly_class_property
    def least_element(cls) -> SyntacticStructure:
        return SyntacticStructure.from_any(cls.is_strictly_less_than_relation.least_element)

    @classmethod
    def sort(cls, *args) -> tuple[SyntacticStructure, ...]:
        r"""Returns `args` sorted in canonical order.

        :param args: An unsorted tuple of LRPTs.
        :return: A canonically sorted tuple of LRPTs.
        """

        def compare(x, y):
            return cls.compare(x, y)

        l: tuple[typing.Any, ...] = tuple(sorted(args, key=functools.cmp_to_key(compare)))
        l: tuple[SyntacticStructure, ...] = tuple(SyntacticStructure.from_any(x) for x in l)
        return l


class SyntacticOrderedSet(SyntacticStructure):
    r"""A syntactic ordered set.

    Definition
    ------------

    A `syntactic ordered set` is a syntactic structure that models a finite (computable) ordered set defined by extension.

    Given LRPT :math:`T` with sub-LRPTs :math:`t_0, t_1, \cdots, t_n`,
    its `syntactic ordered set` is the ordered set :math:`(s_0, s_1, \cdots, s_m)`
    where :math:`s_i` denotes the :math:`i`-th *unique* immediate sub-LRPTs of :math:`T`, preserving order.

    Sample
    --------
    Given :math:`T = 0(3, 1, 1, 1, 2)`, the corresponding syntactic ordered set is :math:`(3, 1, 2)`.

    Note
    ------

    The main element of the LRPT is not an information of the syntactic ordered set, i.e.: it is dropped.

    Note
    -----------

    Every LRPT is a syntactic ordered set.

    Note
    ----------

    Every LRPT of degree 0 is the empty ordered set.

    """

    def __init__(self,
                 *args: SyntacticStructure,
                 n: int | None = None,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticOrderedSet, self).__init__(*args, n=n, rpt=rpt, sequence=sequence)

    def __new__(cls,
                *args: SyntacticStructure,
                n: int | None = None,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(SyntacticOrderedSet, cls).__new__(cls, *args, n=n, rpt=rpt, sequence=sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_ordered_set()

    def __str__(self):
        return self.represent_as_ordered_set()

    _HASH_SEED: int = 16508528480418369971  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    def append(self, x: FlexibleSyntacticStructure) -> SyntacticOrderedSet:
        r"""Return a new poset that contains all the elements of this poset in order, followed by `x`.

        Definition
        ------------
        :math:`A \frown \langle x \rangle`

        :param x: A syntactic structure.
        :return: A syntactic set.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        return SyntacticOrderedSet.from_elements(*self.elements, x, n=self.root_label)

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this syntactic ordered set.

        Note
        ______

        This is equal to the number of unique immediate sub-LRPTs
        in the LRPT of this syntactic structure.

        This is equivalent to the degree of the LRPT
        if its immediate sub-LRPTs are unique.

        :return: an integer.
        """
        return len(self.elements)

    @functools.cached_property
    def elements(self) -> tuple[SyntacticStructure, ...]:
        r"""Returns the elements of this syntactic ordered set, in order.

        Note
        ______

        This is equivalent to the unique and immediate subtrees of the LRPT,
        preserving order,
        and typed as syntactic structures.

        :return: The elements of the ordered set, in order.
        """
        unique_elements: tuple[SyntacticStructure, ...] = ()
        for sub_ss in self.immediate_sub_syntactic_structures:
            if sub_ss not in unique_elements:
                unique_elements = unique_elements + (sub_ss,)
        return unique_elements

    @classmethod
    def from_any(cls, x: FlexibleSyntacticOrderedSet) -> SyntacticOrderedSet:
        if isinstance(x, SyntacticOrderedSet):
            return x
        elif isinstance(x, tuple) and not isinstance(x, lrptl.LRPT):
            # This is a "pure" python tuple,
            # i.e. it is not an LRPT that inherits from python tuple.
            # This signature is interpreted the elements of the syntactic ordered set.
            return cls.from_elements(*x)
        else:
            # Fallback to the original LRPT from_any() method.
            return cls.from_lrpt(x)

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> SyntacticOrderedSet:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        elements = tuple(SyntacticStructure.from_any(x) for x in elements)
        return cls.from_immediate_subtrees(*elements, n=n)

    @classmethod
    def from_empty_ordered_set(cls, n: int | None = None) -> SyntacticOrderedSet:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_root_label(n=n)

    def get_element_by_index(self, i: int) -> lrptl.LabeledRootedPlaneTree:
        if not 0 < i < self.cardinality:
            raise util.PunctiliousException("Index `i` is out of range of this syntactic ordered set.")
        return self.elements[i]

    def get_element_index(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> int:
        if not self.has_element(x):
            raise util.PunctiliousException("`x` is not an element of this syntactic ordered set.", x=x, poset=self)
        return self.elements.index(x)

    def has_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this set, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        x: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_any(x)
        return self.has_immediate_subtree(x)

    def is_syntactic_ordered_set_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is syntactic ordered set equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is syntactic set equivalent to `y` if and only if:

        - every immediate sub-LRPT of :math:`x` is an immediate sub-LRPT of :math:`y`,
        - every immediate sub-LRPT of :math:`y` is an immediate sub-LRPT of :math:`x`,
        - the order of the first occurrence of every sub-LRPT in :math:`x`
          is equal to the order of its first occurrence in :math:`y`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to syntactic set is possible because syntactic ordered sets have no constraints.
        x: SyntacticOrderedSet = SyntacticOrderedSet.from_any(x)

        # direct comparison of elements is possible because order is considered.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed syntactic ordered set.

        But because every LRPT is a syntactic ordered set, this method always returns `True`.

        If `True`, :meth:`SyntacticOrderedSet.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        cls.from_any(o)
        return True

    def prepend(self, x: FlexibleSyntacticStructure) -> SyntacticSet:
        r"""Return a new poset that contains first `x` followed by all the elements of this poset in order.

        Definition
        ------------
        :math:`\langle x \rangle \frown A`

        :param x: A syntactic structure.
        :return: A syntactic set.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        return SyntacticSet.from_elements(x, *self.elements, n=self.root_label)

    def represent_as_ordered_set(self) -> str:
        r"""Returns a string representation of the LRPT using map notation.

        :return: A string representation of this LRPT.

        """
        output = f"⟨ "
        first = True
        for element in self.elements:
            if not first:
                output = f"{output}, "
            output = f"{output}{element}"
            first = False
        output = f"{output} ⟩"

        return output

    def to_set(self) -> SyntacticSet:
        """Return a set from the elements of this ordered set.

        :return: A set.
        :rtype: SyntacticSet
        """
        return SyntacticSet.from_elements(*self.elements)


class SyntacticSet(SyntacticStructure):
    r"""A syntactic set.

    Intuitive definition
    ----------------------

    A `syntactic set` is a syntactic structure that models a finite (computable) set defined by extension.

    Syntactic definition
    -----------------------

    A `syntactic structure` :math:`A` is a `syntactic set` if and only if:

    - Its root label is the conventional label for syntactic sets.
    - Its immediate sub-syntactic structures are ordered in canonical order.

    Note
    ----------

    The empty set is the syntactic structure :math:`n()` where :math:`n` is the conventional label
    for syntactic sets.

    """

    def __init__(self,
                 *args: SyntacticStructure,
                 n: int | None = None,
                 rpt: rptl.FlexibleRootedPlaneTree | None,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence | None):
        super(SyntacticSet, self).__init__(*args, n=n, rpt=rpt, sequence=sequence)

    def __new__(cls,
                *args: SyntacticStructure,
                n: int | None = None,
                rpt: rptl.FlexibleRootedPlaneTree | None,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence | None):
        if rpt is not None:
            lrpt: lrptl.LabeledRootedPlaneTree = lrptl.LabeledRootedPlaneTree.from_rpt_and_sequence(rpt, sequence)
            args = lrpt.immediate_subtrees
            rpt = None
            sequence = None
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        # sort the elements
        args = SyntacticStructure.sort(*args)
        # drop the duplicate elements
        args = SyntacticStructure.drop_duplicates(*args)
        ss = super(SyntacticSet, cls).__new__(cls, *args, n=n, rpt=rpt, sequence=sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_set()

    def __str__(self):
        return self.represent_as_set()

    _HASH_SEED: int = 687807374550534646  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    def adjoin(self, x: FlexibleSyntacticStructure) -> SyntacticSet:
        r"""Return a new set that contains all the elements of this set and `x`.

        Definition
        ------------
        :math:`A \cup \{ x \}`

        :param x: A syntactic structure.
        :return: A syntactic set.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        elements: tuple[SyntacticStructure, ...] = *self.elements, x,
        return SyntacticSet.from_elements(*elements, n=self.root_label)

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this syntactic set.

        Note
        ______

        This is equal to the number of unique immediate sub-LRPTs
        in the LRPT of this syntactic structure.

        This is equivalent to the degree of the LRPT
        if its immediate sub-LRPTs are unique.

        :return: an integer.
        """
        return len(self.elements)

    def cartesian_product(self, x: FlexibleSyntacticSet) -> SyntacticSet:
        r"""Returns the cartesian product of this set and `x`.

        Definition
        ------------
        :math:`A \times B = \{ (a, b) \mid a \in A, b \in B \}` \}`

        :param x: A syntactic set.
        :return: A syntactic set.
        """
        x: SyntacticSet = SyntacticSet.from_any(x)
        y: SyntacticSet = SyntacticSet.from_empty_set()
        for a in self.elements:
            for b in x.elements:
                y = y.adjoin(SyntacticOrderedPair.from_first_and_second_elements(a, b))
        return y

    def difference(self, x: FlexibleSyntacticSet) -> SyntacticSet:
        r"""Returns the difference of this set and `x`.

        Definition
        ------------
        :math:`A \setminus B = \{ x \in A, x \notin B \}`

        :param x: A syntactic set.
        :return: A syntactic set.
        """
        x: SyntacticSet = SyntacticSet.from_any(x)
        y: SyntacticSet = SyntacticSet.from_empty_set()
        for z in self.elements:
            if not x.has_element(z):
                y = y.adjoin(z)
        return y

    @functools.cached_property
    def elements(self) -> tuple[SyntacticStructure, ...]:
        r"""Returns the elements of this syntactic set.

        Note
        ______

        This is equivalent to the unique and immediate subtrees of the LRPT.

        Note
        ------

        Even though sets are not ordered, by convention the elements of a syntactic set
        are ordered by LRPT canonical order, facilitating equivalence checking.

        :return: The elements of the set.
        """
        unique_elements: tuple[SyntacticStructure, ...] = ()
        for sub_ss in self.immediate_sub_syntactic_structures:
            if sub_ss not in unique_elements:
                unique_elements = unique_elements + (sub_ss,)
        # by convention, returns the elements in canonical LRPT order,
        # this facilitates equivalence checking.
        unique_elements = tuple(sorted(unique_elements))
        return unique_elements

    @classmethod
    def from_any(cls, x: FlexibleSyntacticSet) -> SyntacticSet:
        if isinstance(x, SyntacticSet):
            return x
        elif isinstance(x, tuple) and not isinstance(x, lrptl.LRPT):
            # This is a "pure" python tuple,
            # i.e. it is not an LRPT that inherits from python tuple.
            # This signature is interpreted the elements of the syntactic set.
            return cls.from_elements(*x)
        else:
            # Fallback to the original LRPT from_any() method.
            return cls.from_lrpt(x)

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> SyntacticSet:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        elements = tuple(SyntacticStructure.from_any(x) for x in elements)
        return cls.from_immediate_subtrees(*elements, n=n)

    @classmethod
    def from_empty_set(cls, n: int | None = None) -> SyntacticSet:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_root_label(n=n)

    def has_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this set, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        return self.has_immediate_subtree(x)

    def intersection(self, x: FlexibleSyntacticSet) -> SyntacticSet:
        r"""Returns the intersection of this set and `x`.

        :param x: A syntactic set.
        :return: A syntactic set.
        """
        x: SyntacticSet = SyntacticSet.from_any(x)
        y: SyntacticSet = SyntacticSet.from_empty_set()
        for z in self.elements:
            if x.has_element(z):
                y = y.adjoin(z)
        return y

    def is_syntactic_set_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this set is `syntactic set equivalent` to `x`.

        Mathematical definition
        -------------------------

        Let :math:`A`, :math:`B` be sets and :math:`x` be an element of the universe.
        :math:`A` = :math:`Y` if and only if:

        - :math:`\forall x (x \in A \Longleftrightarrow x \in B)`.

        Syntactic definition
        -------------------------

        Let :math:`A`, :math:`B`, and :math:`x` be syntactic structures.
        :math:`A` is syntactic set equivalent to :math:`Y` if and only if:

        - :math:`A` and :math:`B` are syntactic sets.
        - :math:`\forall x (x \in A \Longleftrightarrow x \in B)`.


        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to syntactic set is possible because syntactic sets have no constraints.
        x: SyntacticSet = SyntacticSet.from_any(x)

        # direct comparison of elements is possible because they are canonically ordered by convention.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls, o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed syntactic set.

        But because every LRPT is a syntactic set, this method always returns `True`.

        If `True`, :meth:`SyntacticSet.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        cls.from_any(o)
        return True

    def represent_as_set(self) -> str:
        r"""Returns a string representation of the LRPT using map notation.

        :return: A string representation of this LRPT.

        """
        output = f"{{ "
        first = True
        for element in self.elements:
            if not first:
                output = f"{output}, "
            output = f"{output}{element}"
            first = False
        output = f"{output} }}"

        return output

    def symmetric_difference(self, x: FlexibleSyntacticSet) -> SyntacticSet:
        r"""Returns the symmetric difference of this set and `x`.

        Definition
        ------------
        :math:`A \triangle B = \{ ( x \in A \land x \notin B ) \lor ( x \notin A \land x \in B ) \}`

        :param x: A syntactic set.
        :return: A syntactic set.
        """
        x: SyntacticSet = SyntacticSet.from_any(x)
        return self.difference(x).union(x.difference(self))

    def union(self, x: FlexibleSyntacticSet) -> SyntacticSet:
        r"""Returns the union of this set and `x`.

        :param x:
        :return:
        """
        x: SyntacticSet = SyntacticSet.from_any(x)
        return SyntacticSet.from_elements(*self.elements, *x.elements)


class SyntacticMap(SyntacticSet):
    r"""A syntactic map.

    Definition
    ------------

    A `syntactic map` is a syntactic structure that models a finite (computable) map defined by extension.

    Given any LRPT :math:`T` with the following constraints:
    - it contains n sub-LRPTs
    - every sub-LRPT is a syntactic ordered pair

    The domain of the map is the ordered set of the first elements of every pair.

    The codomain of the map is the tuple of the second elements of every pair.

    its `syntactic map` is the map that to the :math:`i`-th element of the domain,
    maps the :math:`i`-th element of the codomain,
    and that is otherwise undefined.

    Note
    ------

    The main element of the LRPT and the main element of the first two immediate sub-LRPTs are not an information of the syntactic map, i.e.: it is dropped.
    Any immediate sub-LRPT of the LRPT beyond 2 is not an information of the syntactic map, i.e. it is dropped.

    Note
    -----------

    Every LRPT of degree > 1 is a syntactic map.

    Note
    ----------

    If the domain is the empty ordered set, it is the empty map.

    Note
    -----------

    There are two distinctive implementations of a syntactic map:

    As a set of ordered pairs:
    { (p_0, i_0), (p_1, i_1), ..., (p_n, i_n) }.

    As an ordered pair whose first element is an ordered set and second element is a tuple :
    ( (p0, p_1, ..., p_n), (i_0, i_1, ..., i_n) }.

    The former is more "accurate" as the equivalence of maps can be directly determined.
    But it requires more object lookups when looking for map values.

    The latter is less "accurate" in the sense that two distinct maps can be equivalent,
    e.g.: ( (1, 2, 3), (4, 5, 6) ) ~ ( (3, 2, 1), (6, 5, 4) ).

    """

    def __init__(self,
                 *args: SyntacticStructure,
                 n: int | None = None,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticMap, self).__init__(*args, n=n, rpt=rpt, sequence=sequence)

    def __new__(cls,
                *args: SyntacticStructure,
                n: int | None = None,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(SyntacticMap, cls).__new__(cls, *args, n=n, rpt=rpt, sequence=sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_inline_map()

    def __str__(self):
        return self.represent_as_inline_map()

    _HASH_SEED: int = 15749856293511400051  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    def append_pair(self, preimage: FlexibleSyntacticStructure, image: FlexibleSyntacticStructure):
        r"""

        :param preimage:
        :param image:
        :return:
        """
        pair: SyntacticOrderedPair = SyntacticOrderedPair(preimage, image)
        return SyntacticMap.from_ordered_pairs(*self.ordered_pairs, pair, n=self.root_label)

    @functools.cached_property
    def codomain(self) -> SyntacticTuple:
        r"""Returns the codomain of this map."""
        output: SyntacticTuple = SyntacticTuple.from_empty_tuple(n=self.root_label)
        pair: SyntacticOrderedPair
        for pair in self.ordered_pairs:
            image: SyntacticStructure = pair.second_element
            output = output.append(image)
        return output

    @functools.cached_property
    def domain(self) -> SyntacticOrderedSet:
        r"""Returns the domain of this map."""
        output: SyntacticOrderedSet = SyntacticOrderedSet.from_empty_ordered_set(n=self.root_label)
        pair: SyntacticOrderedPair
        for pair in self.ordered_pairs:
            preimage: SyntacticStructure = pair.first_element
            output = output.append(preimage)
        return output

    @classmethod
    def from_domain_and_codomain(cls,
                                 domain: FlexibleSyntacticOrderedSet,
                                 codomain: FlexibleSyntacticSet,
                                 n: int = 0
                                 ) -> SyntacticMap:
        domain: SyntacticOrderedSet = SyntacticOrderedSet.from_any(domain)
        codomain: SyntacticTuple = SyntacticTuple.from_any(codomain)
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        # data validation: checks that cardinality of domain and codomain are equal.
        if domain.cardinality != codomain.cardinality:
            raise util.PunctiliousException(
                f"The cardinality of the domain ({domain.cardinality}) and the codomain ({codomain.cardinality}) are not equal.",
                domain=domain,
                codomain=codomain)

        # populate the ordered pairs.
        ordered_pairs: SyntacticSet = SyntacticSet.from_empty_set(n=n)
        for preimage, image in zip(domain.elements, codomain.elements):
            pair: SyntacticOrderedPair = SyntacticOrderedPair.from_first_and_second_elements(preimage, image)
            ordered_pairs = ordered_pairs.adjoin(pair)

        return cls.from_ordered_pairs(*ordered_pairs.elements, n=n)

    @classmethod
    def from_empty_map(cls, n: int | None = None) -> SyntacticMap:
        r"""Returns an empty map.

        :return: A map.
        """
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_ordered_pairs(n=n)

    @classmethod
    def from_ordered_pairs(cls, *ordered_pairs: FlexibleSyntacticOrderedPair, n: int | None = 0) -> SyntacticMap:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        ordered_pairs: tuple[SyntacticOrderedPair, ...] = tuple(SyntacticOrderedPair.from_any(x) for x in ordered_pairs)
        return cls.from_elements(*ordered_pairs, n=n)

    def get_value(self, x: FlexibleSyntacticStructure) -> SyntacticStructure:
        r"""If this LRPT is a syntactic-map, returns the image `x` under this map.

        :param x: a preimage element.
        :return: the image of `t` under this map.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        if not self.domain.has_element(x):
            raise util.PunctiliousException("`x` is not an element of the domain.", x=x, domain=self.domain)
        else:
            i: int = self.domain.get_element_index(x)
            return self.codomain.get_element_by_index(i)

    def has_domain_element(self, x: lrptl.FlexibleLabeledRootedPlaneTree) -> bool:
        r"""Returns `True` if `x` is an element of this syntactic map domain, `False` otherwise.

        :param x: An object.
        :return: `True` or `False`
        """
        return self.domain.has_element(x)

    def is_syntactic_map_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is syntactic map equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is syntactic map equivalent to `y` if and only if:

        - :math:`x` and :math:`y` are syntactic maps,
        - the set of ordered pairs of :math:`x` is syntactic set equivalent
          to the set of ordered pairs of :math:`y`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """
        x: SyntacticMap = SyntacticMap.from_any(x)
        if not SyntacticMap.is_well_formed(x, raise_exception_if_false=False):
            return False
        else:
            x: SyntacticMap = SyntacticMap.from_any(x)
            if not self.ordered_pairs.is_syntactic_set_equivalent_to(x.ordered_pairs):
                return False
            return True

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure,
            raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is well-formed,
        that if it complies with all constraints applicable to this syntactic structure.

        If `True`, :meth:`SyntacticStructure.from_any` can be safely called on `o`.

        TODO: rewrite SyntacticMap.is_well_formed. The original structure was based
          on (domain, codomain) and we now moved to pairs. Adapt the logic accordingly.

        :param o: A syntactic structure or an LRPT.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        if isinstance(o, SyntacticMap):
            return True
        ss: SyntacticStructure = cls.from_any(o)
        if ss.degree < 2:
            if raise_exception_if_false:
                raise util.PunctiliousException("deg(T) < 2.", deg_t=ss.degree,
                                                t=ss)
            else:
                return False
        if not SyntacticOrderedSet.is_well_formed(ss.immediate_subtrees[0]):
            if raise_exception_if_false:
                raise util.PunctiliousException("First subtree is not a well-formed syntactic ordered set.",
                                                first_subtree=ss.immediate_subtrees[0])
            else:
                return False
        if not SyntacticTuple.is_well_formed(ss.immediate_subtrees[1]):
            if raise_exception_if_false:
                raise util.PunctiliousException("Second subtree is not a well-formed syntactic ordered set.",
                                                second_subtree=ss.immediate_subtrees[1])
            else:
                return False
        domain: SyntacticOrderedSet = SyntacticOrderedSet.from_lrpt(ss.immediate_sub_syntactic_structures[0])
        codomain: SyntacticTuple = SyntacticTuple.from_lrpt(ss.immediate_sub_syntactic_structures[1])
        if domain.cardinality != codomain.cardinality:
            if raise_exception_if_false:
                raise util.PunctiliousException(
                    "The cardinality of the domain is not equal to the cardinality of the codomain.",
                    domain=domain, codomain=codomain)
            else:
                return False
        # The syntactic structure satisfies all constraints.
        return True

    @functools.cached_property
    def ordered_pairs(self) -> tuple[SyntacticOrderedPair, ...]:
        r"""Returns the ordered pairs that constitutes this syntactic map.

        :return: A python tuple of pairs.
        """
        return tuple(SyntacticOrderedPair.from_any(x) for x in self.elements)

    def represent_as_inline_map(self) -> str:
        r"""Returns a string representation of the LRPT using map notation.

        :return: A string representation of this LRPT.

        """
        output = f"{{ "
        first = True
        for preimage, image in zip(
                self.domain.elements,
                self.codomain.elements):
            if not first:
                output = f"{output}, "
            output = f"{output}{preimage} ⟼ {image}"
            first = False
        output = f"{output} }}"

        return output

    def substitute(self, x: FlexibleSyntacticStructure) -> SyntacticStructure:
        r"""Returns a new Syntactic Structure similar to :math:`x`,
         with the difference that any preimage subtree present in the domain of this syntactic map,
         is substituted with its corresponding image in the map codomain,
         giving priority to the substitution of supertrees over subtrees.

        :param x: A syntactic structure.
        :return: A substituted tree.

        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        if self.has_domain_element(x):
            # This formula must be substituted according to the substitution map.
            return self.get_value(x)
        else:
            # Pursue substitution recursively.
            t: SyntacticStructure
            s: tuple[SyntacticStructure, ...] = tuple(
                self.substitute(y) for y in x.immediate_sub_syntactic_structures)
            return SyntacticStructure.from_immediate_subtrees(*s, n=x.root_label)

    def to_syntactic_set(self):
        r"""Returns the set of ordered pairs that constitutes this map.

        Note
        -----

        Every map is a set of ordered pairs.

        :return: A set.
        """
        return SyntacticSet.from_elements(*self.ordered_pairs)


class SyntacticTuple(SyntacticStructure):
    r"""A syntactic tuple.

    Definition
    ------------

    A `syntactic tuple` is a syntactic structure that models a finite (computable) tuple defined by extension.

    Given any LRPT :math:`T`,
    its `syntactic tuple` is the tuple :math:`{t_0, t_1, \cdots, t_n}`
    where :math:`t_i` denotes the immediate sub-LRPTs of :math:`T`.

    Note
    ------

    The main element of the LRPT is not an information of the syntactic set, i.e.: it is dropped.

    Note
    -----------

    Every LRPT is a syntactic tuple.

    Note
    ----------

    Every LRPT of degree 0 is the empty tuple.

    """

    def __init__(self,
                 *args: SyntacticStructure,
                 n: int | None = None,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticTuple, self).__init__(*args, n=n, rpt=rpt, sequence=sequence)

    def __new__(cls,
                *args: SyntacticStructure,
                n: int | None = None,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(SyntacticTuple, cls).__new__(cls, *args, n=n, rpt=rpt, sequence=sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_tuple()

    def __str__(self):
        return self.represent_as_tuple()

    _HASH_SEED: int = 12503318805270547491  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    def append(self, x: FlexibleSyntacticStructure) -> SyntacticTuple:
        r"""Return a new tuple that contains all the elements of this tuple in order, followed by `x`.

        Definition
        ------------
        :math:`A \frown \langle x \rangle`

        :param x: A syntactic structure.
        :return: A syntactic tuple.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        return SyntacticTuple.from_elements(*self.elements, x, n=self.root_label)

    @functools.cached_property
    def cardinality(self) -> int:
        r"""Returns the cardinality of this syntactic tuple.

        Note
        ______

        This is equivalent to the degree of the LRPT.

        :return: an integer.
        """
        return len(self.elements)

    @functools.cached_property
    def elements(self) -> tuple[SyntacticStructure, ...]:
        r"""Returns the elements of this syntactic tuple, preserving order.

        Note
        ______

        This is equivalent to the immediate subtrees of the LRPT,
        typed as syntactic structures.

        :return: The elements of the tuple.
        """
        return self.immediate_sub_syntactic_structures

    @classmethod
    def from_any(cls, x: FlexibleSyntacticTuple) -> SyntacticTuple:
        if isinstance(x, SyntacticTuple):
            return x
        elif isinstance(x, tuple) and not isinstance(x, lrptl.LRPT):
            # This is a "pure" python tuple,
            # i.e. it is not an LRPT that inherits from python tuple.
            # This signature is interpreted the elements of the syntactic tuple.
            return cls.from_elements(*x)
        else:
            # Fallback to the original LRPT from_any() method.
            return cls.from_lrpt(x)

    @classmethod
    def from_elements(cls,
                      *elements: lrptl.FlexibleLabeledRootedPlaneTree,
                      n: int | None = None,
                      ) -> SyntacticTuple:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        elements = tuple(SyntacticStructure.from_any(x) for x in elements)
        return cls.from_immediate_subtrees(*elements, n=n)

    @classmethod
    def from_empty_tuple(cls, n: int | None = None) -> SyntacticTuple:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        return cls.from_root_label(n=n)

    def get_element_by_index(self, i: int) -> SyntacticStructure:
        if i < 0 or i >= self.cardinality:
            raise util.PunctiliousException("Index `i` is out of range of this syntactic tuple `t`.", i=i,
                                            degree_of_t=self.degree, t=self)
        return self.elements[i]

    def has_element(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Returns `True` if `x` is an element of this tuple, `False` otherwise.

        Definition
        ------------

        :math:`x` is an element of syntactic tuple :math:`S` if and only if there exists
        an immediate sub-LRPT :math:`y` of :math:`S` such that :math:`x \quad \sim_{LRPT} \quad y`.

        Note
        ------

        An element `x` may appear multiple times in a syntactic tuple.

        :param x: An object.
        :return: `True` or `False`
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        return self.has_immediate_subtree(x)

    def is_syntactic_tuple_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is syntactic tuple equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be LRPTs.
        :math:`x` is syntactic tuple equivalent to `y` if and only if:

        - the degree of :math:`x` is equal to the degree of :math:`y`,
        - :math:`x_i` is LRPT equivalent to :math:`x_i` for :math:`0 <= i < \mathrm{deg}(x)`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        # direct conversion to syntactic tuple is possible because syntactic tuples have no constraints.
        x: SyntacticTuple = SyntacticTuple.from_any(x)

        # direct comparison of elements is possible because they are canonically ordered by convention.
        return self.elements == x.elements

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed syntactic tuple.

        But because every LRPT is a syntactic tuple, this method always returns `True`.

        If `True`, :meth:`SyntacticTuple.from_any` can be safely called on `o`.

        :param o: A syntactic structure or an LRPT.
        :return: `True` or `False`.
        """

        # this syntactic structure has no constraint,
        # check only python type compatibility with SyntacticStructure.
        cls.from_any(o)
        return True

    def prepend(self, x: FlexibleSyntacticStructure) -> SyntacticTuple:
        r"""Return a new tuple that contains `x` followed by all the elements of this tuple in order.

        Definition
        ------------
        :math:`\langle x \rangle \frown A`

        :param x: A syntactic structure.
        :return: A syntactic tuple.
        """
        x: SyntacticStructure = SyntacticStructure.from_any(x)
        return SyntacticTuple.from_elements(x, *self.elements, n=self.root_label)

    def represent_as_tuple(self) -> str:
        r"""Returns a string representation of tuple.

        :return: A string.

        """
        output = f"⟨ "
        first = True
        for element in self.elements:
            if not first:
                output = f"{output}, "
            output = f"{output}{element}"
            first = False
        output = f"{output} ⟩"

        return output

    def to_set(self) -> SyntacticSet:
        """Return a set from the elements of this tuple.

        :return: A set.
        :rtype: SyntacticSet
        """
        return SyntacticSet.from_elements(*self.elements)


class SyntacticOrderedPair(SyntacticTuple):
    r"""A syntactic ordered pair.

    Definition
    ------------

    A `syntactic ordered pair` is a syntactic structure that models an ordered pair.

    Given any LRPT :math:`T` of degree >= 2,
    its `syntactic ordered pair` is the tuple :math:`(t_0, t_1)`
    where :math:`t_i` denotes the :math:`i`-th immediate sub-LRPT of :math:`T`.

    Note
    ------

    The main element of the LRPT is not an information of the syntactic ordered pair, i.e.: it is dropped.

    Note
    -----------

    Every LRPT of degree >= 2 is a syntactic ordered pair.

    """

    def __init__(self,
                 *args: SyntacticStructure,
                 n: int | None = None,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticOrderedPair, self).__init__(*args, n=n, rpt=rpt, sequence=sequence)

    def __new__(cls,
                *args: SyntacticStructure,
                n: int | None = None,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(SyntacticOrderedPair, cls).__new__(cls, *args, n=n, rpt=rpt, sequence=sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_ordered_pair()

    def __str__(self):
        return self.represent_as_ordered_pair()

    _HASH_SEED: int = 12810223144789917182  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @functools.cached_property
    def first_element(self) -> SyntacticStructure:
        return self.elements[0]

    @classmethod
    def from_first_and_second_elements(cls,
                                       first_element: FlexibleSyntacticStructure,
                                       second_element: FlexibleSyntacticStructure,
                                       n: int | None = None,
                                       ) -> SyntacticOrderedPair:
        r"""Returns the syntactic ordered pair :math:`(x, y)`
        where :math:`x` is the first element,
        and :math:`y` is the second element.

        :param first_element: A syntactic structure.
        :param second_element: A syntactic structure.
        :param n: (conditional) The main element of the LRPT.
        :return: A syntactic ordered pair.
        """
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        first_element: SyntacticStructure = SyntacticStructure.from_any(first_element)
        second_element: SyntacticStructure = SyntacticStructure.from_any(second_element)
        return cls.from_immediate_subtrees(first_element, second_element, n=n)

    def is_syntactic_ordered_pair_equivalent_to(self, x: FlexibleSyntacticStructure) -> bool:
        r"""Check if this syntactic structure is syntactic ordered pair equivalent to `x`.

        Definition
        ---------------

        Let :math:`x`, :math:`y` be syntactic ordered pairs.
        :math:`x` is syntactic ordered pair equivalent to `y` if and only if:

        - The first element of :math:`x` is LRPT equivalent to the first element of :math:`y`.
        - The second element of :math:`x` is LRPT equivalent to the second element of :math:`y`.

        :param x: A syntactic structure.
        :return: `True` or `False`.
        """

        x: SyntacticStructure = SyntacticStructure.from_any(x)
        if not SyntacticOrderedPair.is_well_formed(x):
            return False
        else:
            x: SyntacticOrderedPair = SyntacticOrderedPair.from_any(x)
            if not x.first_element.is_labeled_rooted_plane_tree_equivalent_to(self.first_element):
                return False
            if not x.second_element.is_labeled_rooted_plane_tree_equivalent_to(self.second_element):
                return False
            return True

    @classmethod
    def is_well_formed(
            cls,
            o: FlexibleSyntacticStructure, raise_exception_if_false: bool = False) -> bool:
        r"""Check if the given `o` is a well-formed syntactic ordered pair.

        If `True`, :meth:`SyntacticOrderedPair.from_any` can be safely called on `o`.

        :param o: A syntactic structure.
        :param raise_exception_if_false:
        :return: `True` or `False`.
        """

        o: SyntacticStructure = cls.from_any(o)
        if o.degree >= 2:
            return True
        else:
            return False

    def represent_as_ordered_pair(self) -> str:
        r"""Returns a string representation of this ordered pair.

        :return: A string.
        """
        return f"⟨ {self.first_element}, {self.second_element} ⟩"

    @functools.cached_property
    def second_element(self) -> SyntacticStructure:
        return self.elements[1]

    def to_set(self) -> SyntacticSet:
        """Return a set from the elements of this ordered pair.

        :return: A set.
        :rtype: SyntacticSet
        """
        return SyntacticSet.from_elements(*self.elements)


class SyntacticTemplate(SyntacticTuple):
    r"""

    """

    def __init__(self,
                 *args: SyntacticStructure,
                 n: int | None = None,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticTemplate, self).__init__(*args, n=n, rpt=rpt, sequence=sequence)

    def __new__(cls,
                *args: SyntacticStructure,
                n: int | None = None,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(SyntacticTemplate, cls).__new__(cls, *args, n=n, rpt=rpt, sequence=sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    def __repr__(self):
        return self.represent_as_template()

    def __str__(self):
        return self.represent_as_template()

    _HASH_SEED: int = 9091532475835818634  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def from_variables_and_template(cls,
                                    variables: FlexibleSyntacticSet,
                                    template: FlexibleSyntacticStructure,
                                    n: int | None = None,
                                    ) -> SyntacticTemplate:
        if n is None:
            n: int = 0  # by convention, 0 is the default main element.
        else:
            n: int = int(n)
        variables: SyntacticSet = SyntacticSet.from_any(variables)
        template: SyntacticStructure = SyntacticStructure.from_any(template)
        return cls.from_immediate_subtrees(variables, template, n=n)

    def represent_as_template(self):
        return self.represent_as_function()

    @functools.cached_property
    def template(self) -> SyntacticStructure:
        return self.elements[1]

    @functools.cached_property
    def variables(self) -> SyntacticSet:
        x: SyntacticStructure = self.elements[0]
        if isinstance(x, SyntacticSet):
            return x
        else:
            raise util.PunctiliousException("`x` is not of type SyntacticSet.", x_type=type(x), x=x)


class SyntacticInferenceRule(SyntacticStructure):
    r"""A syntactic inference rule.

    Definition
    ------------

    A `syntactic inference rule` is a syntactic structure that models an inference rule of the form:

    Given :math:`x_1, x_2, \cdots, x_n` denoted as the variables.

    Given theorems :math:`\Psi_1, \Psi_2, \cdots, \Psi_m` denoted as the premises (possibly containing instances of the above variables):

    Theorem :math:`\Phi` denoted as the conclusion follows (possibly containing instances of the above variables).

    """

    def __init__(self,
                 *args: SyntacticStructure,
                 n: int | None = None,
                 rpt: rptl.FlexibleRootedPlaneTree,
                 sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        super(SyntacticInferenceRule, self).__init__(*args, n=n, rpt=rpt, sequence=sequence)

    def __new__(cls,
                *args: SyntacticStructure,
                n: int | None = None,
                rpt: rptl.FlexibleRootedPlaneTree,
                sequence: nn0sl.FlexibleNaturalNumber0Sequence):
        ss = super(SyntacticInferenceRule, cls).__new__(cls, *args, n=n, rpt=rpt, sequence=sequence)
        cls.is_well_formed(ss, raise_exception_if_false=True)
        return ss

    _HASH_SEED: int = 166751588910771296  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def from_components(cls,
                        variables: FlexibleSyntacticSet,
                        premises: FlexibleSyntacticSet,
                        conclusion: lrptl.FlexibleLabeledRootedPlaneTree,
                        n: int = 0
                        ) -> SyntacticInferenceRule:
        variables = SyntacticSet.from_elements(*variables)
        premises = SyntacticOrderedSet.from_elements(*premises)
        conclusion = SyntacticStructure.from_any(conclusion)
        n: int = int(n)
        return cls.from_immediate_subtrees(variables, premises, conclusion, n=n)

    def apply(self, premises: FlexibleSyntacticOrderedSet) -> SyntacticStructure:
        premises: SyntacticOrderedSet = SyntacticOrderedSet.from_any(premises)
        status, assigned_variables = self.check_premises(premises)
        if not status:
            raise util.PunctiliousException("premises are invalid for this inference rule.", premises=premises,
                                            inference_rule=self)
        else:
            conclusion: SyntacticStructure = assigned_variables.substitute(self.conclusion)
            return conclusion

    def check_premises(self, premises: FlexibleSyntacticSet) -> tuple[bool, SyntacticMap]:
        premises: SyntacticSet = SyntacticSet.from_any(premises)
        assigned_variables: SyntacticMap = SyntacticMap()
        for premise, premise_with_variables in zip(premises.elements, self.premises.elements):
            status, assigned_variables = self.check_premise(premise, premise_with_variables,
                                                            assigned_variables)
            if not status:
                return False, assigned_variables
        return True, assigned_variables

    def check_premise(self,
                      premise: FlexibleSyntacticStructure,
                      premise_with_variables: FlexibleSyntacticStructure,
                      assigned_variables: FlexibleSyntacticMap) -> tuple[bool, SyntacticMap]:
        premises: SyntacticStructure = SyntacticStructure.from_any(premise)
        premise_with_variables: SyntacticStructure = SyntacticStructure.from_any(premise_with_variables)
        assigned_variables: SyntacticMap = SyntacticMap.from_any(assigned_variables)
        # substitute already assigned variables
        premise_with_variables: SyntacticStructure = assigned_variables.substitute(assigned_variables)
        free_variables: SyntacticSet = self.variables.elements.difference(assigned_variables.domain.elements)
        COMPARE_HERE

    @functools.cached_property
    def conclusion(self) -> SyntacticStructure:
        return self.immediate_sub_syntactic_structures[2]

    @functools.cached_property
    def premises(self) -> SyntacticOrderedSet:
        return SyntacticOrderedSet.from_lrpt(self.immediate_sub_syntactic_structures[1])

    @functools.cached_property
    def variables(self) -> SyntacticSet:
        return SyntacticSet.from_lrpt(self.immediate_sub_syntactic_structures[0])


def match(self,
          free_variables: FlexibleSyntacticSet,
          template: FlexibleSyntacticStructure,
          x: FlexibleSyntacticStructure) -> bool:
    output: bool
    variable_assignments: SyntacticMap = SyntacticMap.from_empty_map()
    output, _, _ = match_with_assignments(
        free_variables=free_variables,
        template=template,
        x=x,
        variable_assignments=variable_assignments)
    return output


def match_with_assignments(self,
                           free_variables: FlexibleSyntacticSet,
                           template: FlexibleSyntacticStructure,
                           x: FlexibleSyntacticStructure,
                           variable_assignments: FlexibleSyntacticMap) -> tuple[bool, SyntacticSet, SyntacticMap]:
    r"""Checks if the `template` matches `x` given the `variables`."""

    # data validation of input values
    free_variables: SyntacticSet = SyntacticSet.from_any(x)
    template: SyntacticStructure = SyntacticStructure.from_any(template)
    x: SyntacticStructure = SyntacticStructure.from_any(x)
    variable_assignments: SyntacticMap = SyntacticMap.from_any(variable_assignments)

    # data validation: check that variables are either free variables, or assigned variables,
    # but not both.
    common_variables: SyntacticSet = free_variables.intersection(variable_assignments.domain)
    if common_variables.cardinality > 0:
        raise util.PunctiliousException(f"Some variable is both free and assigned.",
                                        common_variables=common_variables,
                                        free_variables=free_variables,
                                        assigned_variables=variable_assignments.domain)

    # data validation: check that `x` does not contain any variable.
    # only `self` may contain variables.
    # an alternative would be to dynamically replace all variables
    # with unique elements when matching, but this looks "heavy".
    # another alternative would be to promote variables as
    # first-order objects and manage their unicity somehow under the hood.
    variable: SyntacticStructure
    for variable in free_variables.elements:
        if x.has_sub_syntactic_structure(variable):
            raise util.PunctiliousException(f"`x` contains a free variable.",
                                            variable=variable,
                                            x=x,
                                            template=self)
    for variable in variable_assignments.domain.elements:
        if x.has_sub_syntactic_structure(variable):
            raise util.PunctiliousException(f"`x` contains an assigned variable.",
                                            variable=variable,
                                            x=x,
                                            template=self)

    # case #1: the left side is an assigned variable.
    if variable_assignments.domain.has_element(template):
        # retrieve the assigned value.
        value: SyntacticStructure = variable_assignments.get_value(template)

        # case #1-1: the variable is assigned to the same value.
        if value.is_syntactic_structure_equivalent_to(x):
            return True, free_variables, variable_assignments

        # case #1-2: the variable is assigned to a different value.
        else:
            return False, free_variables, variable_assignments

    # case #2: the left side is a free variable.
    elif free_variables.has_element(template):

        # case #2-1: there are some free variable left.
        if free_variables.cardinality > 0:
            # pick the first free variable that is available.
            variable = free_variables.elements[0]
            # assign the value.
            variable_assignments.append_pair(preimage=variable, image=x)

        # case #2-2: there is no more variable left.
        else:
            # conclusion: the two structures don't match.
            return False, free_variables, variable_assignments

    # case #3: the two structures are equivalent.
    elif template.is_syntactic_structure_equivalent_to(x):
        return True, variable_assignments

    # case #4: the two structures don't match.
    else:
        pass


# Flexible types to facilitate data validation

FlexibleSyntacticMap = typing.Union[
    SyntacticMap,
    lrptl.LabeledRootedPlaneTree,  # already typed as LRPT.
    tuple[rptl.FlexibleRootedPlaneTree, ...],  # the elements of the syntactic set.
    None  # the empty syntactic set.
]
FlexibleSyntacticOrderedSet = typing.Union[
    SyntacticOrderedSet,
    lrptl.LabeledRootedPlaneTree,  # already typed as LRPT.
    tuple[rptl.FlexibleRootedPlaneTree, ...],  # the elements of the syntactic set.
    None  # the empty syntactic set.
]
FlexibleSyntacticOrderedPair = typing.Union[
    SyntacticOrderedPair,
    SyntacticOrderedSet,  # assuming cardinality = 2.
    lrptl.LabeledRootedPlaneTree,  # already typed as LRPT.
    tuple[rptl.FlexibleRootedPlaneTree, ...],  # the elements of the syntactic set.
    None  # the empty syntactic set.
]
FlexibleSyntacticSet = typing.Union[
    SyntacticSet,
    lrptl.LabeledRootedPlaneTree,  # already typed as LRPT.
    tuple[rptl.FlexibleRootedPlaneTree, ...],  # the elements of the syntactic set.
    None  # the empty syntactic set.
]
FlexibleSyntacticTuple = typing.Union[
    SyntacticTuple,
    lrptl.LabeledRootedPlaneTree,  # already typed as LRPT.
    tuple[rptl.FlexibleRootedPlaneTree, ...],  # the elements of the syntactic set.
    None  # the empty syntactic set.
]
FlexibleSyntacticStructure = typing.Union[
    SyntacticStructure,
    lrptl.FlexibleLabeledRootedPlaneTree]

# Aliases

FSS = FlexibleSyntacticStructure
SIR = SyntacticInferenceRule  # An alias for :class:`SyntacticInferenceRule`.
SM = SyntacticMap  # An alias for :class:`SyntacticMap`.
SOS = SyntacticOrderedSet  # An alias for :class:`SyntacticOrderedSet`.
SS = SyntacticSet  # An alias for :class:`SyntacticSet`.
ST = SyntacticTuple  # An alias for :class:`SyntacticTuple`.
