from __future__ import annotations
# import itertools
import typing
import collections
import functools
import uuid

# package modules
import punctilious.util as util
import punctilious.ternary_boolean_library as tbl
import punctilious.binary_relation_library as brl
# import punctilious.rooted_plane_tree_library as rptl
import punctilious.natural_number_0_sequence_library as nn0sl
import punctilious.connective_library as cl
import punctilious.special_values_library as spl


# Binary Relations


class IsEqualTo(brl.BinaryRelation):
    r"""The connective sequence class equipped with the standard equality order relation.

    Mathematical definition
    -------------------------

    :math:`( \mathbb{F}, = )`.

    """

    @util.readonly_class_property
    def is_antisymmetric(cls) -> tbl.TernaryBoolean:
        r"""

        Proof
        ------

        TODO: Provide proof here.

        """
        return tbl.TernaryBoolean.TRUE

    @classmethod
    def relates(cls, x: object, y: object) -> bool:
        r"""Returns `True` if :math:`xRy`, `False` otherwise.

        :param x: A Python object.
        :param y: A Python object.
        :return: `True` or `False`.
        """
        x: ConnectiveSequence = ConnectiveSequence.from_any(x)
        y: ConnectiveSequence = ConnectiveSequence.from_any(y)
        return x.is_connective_sequence_equivalent_to(y)


class CombinedFixedLengthIntegersWithSentinelOrder(brl.BinaryRelation):
    r"""The combined fixed-length integers with sentinel order of connective sequences.

    Note
    ------

    Connective uids have maximal value: :math:`n^128`.

    In this context, reusing the combined fixed-length integers with sentinel order
    is a natural option.

    """

    @util.readonly_class_property
    def is_order_isomorphic_with_n_strictly_less_than(cls) -> tbl.TernaryBoolean:
        r"""

        Proof
        ------

        TODO: Provide proof here.

        """
        return tbl.TernaryBoolean.FALSE

    @util.readonly_class_property
    def least_element(cls) -> ConnectiveSequence:
        return ConnectiveSequence()

    @classmethod
    def rank(cls, x: FlexibleConnectiveSequence) -> int:
        x: ConnectiveSequence = ConnectiveSequence.from_any(x)
        # builds a (0-based) natural number sequence
        # from the integer values of the connective uuids.
        c: cl.Connective
        s: tuple[int, ...] = tuple(c.uid.int for c in x.elements)
        s: nn0sl.NaturalNumber0Sequence = nn0sl.NaturalNumber0Sequence(*s)
        return nn0sl.combined_fixed_length_integers_with_sentinel_order.rank(s)

    @classmethod
    def relates(cls, x: object, y: object) -> bool:
        x: ConnectiveSequence = ConnectiveSequence.from_any(x)
        y: ConnectiveSequence = ConnectiveSequence.from_any(y)
        r1: int = cls.rank(x)
        r2: int = cls.rank(y)
        return r1 < r2

    @classmethod
    def successor(cls, x: object) -> object | typing.Literal[spl.SpecialValues.NOT_AVAILABLE]:
        x: ConnectiveSequence = ConnectiveSequence.from_any(x)
        # builds a (0-based) natural number sequence
        # from the integer values of the connective uuids.
        c: cl.Connective
        s: tuple[int, ...] = tuple(c.uid.int for c in x.elements)
        s: nn0sl.NaturalNumber0Sequence = nn0sl.NaturalNumber0Sequence(*s)
        # get the success of the (0-based) natural number sequence
        s2: nn0sl.NaturalNumber0Sequence = nn0sl.combined_fixed_length_integers_with_sentinel_order.successor(s)
        # rank it and unrank it ;-)
        r: int = nn0sl.combined_fixed_length_integers_with_sentinel_order.rank(s2)
        x2: ConnectiveSequence = cls.unrank(r)
        return x2

    @classmethod
    def unrank(cls, n: int) -> object:
        s: nn0sl.NaturalNumber0Sequence = nn0sl.combined_fixed_length_integers_with_sentinel_order.unrank(n)
        uids: tuple[uuid.UUID, ...] = tuple(uuid.UUID(int=int(i)) for i in s.elements)
        c: tuple[cl.Connective, ...] = tuple(cl.Connective("Anonymous connective", uid=uid) for uid in uids)
        return ConnectiveSequence(*c)


# General functions


# Classes


class ConnectiveSequence(brl.ClassWithOrder, tuple):
    """A finite (computable) sequence of at least 1 connectives.

    """

    def __hash__(self):
        return self._compute_hash(self)

    def __init__(self, *s):
        super(ConnectiveSequence, self).__init__()

    def __new__(cls, *s):
        v: bool
        s: tuple[cl.Connective, ...]
        v, s = cls.data_validate_elements(s)
        s: tuple[cl.Connective] = super(ConnectiveSequence, cls).__new__(cls, s)
        s: tuple[cl.Connective] = cls._from_cache(s)
        return s

    _cache: dict[
        int, ConnectiveSequence] = dict()  # cache for ConnectiveSequence.

    _HASH_SEED: int = 642062802475784292  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def _compute_hash(cls, o: FlexibleConnectiveSequence) -> int:
        """Exposes the hashing logic as a static method.

        :param o: An object that is structurally compatible with a natural-number-sequence.
        :return: The hash of the natural-number-sequence that is structurally equivalent to `o`.
        """
        return hash((ConnectiveSequence, cls._HASH_SEED, o.elements,))

    @classmethod
    def _from_cache(cls, o: FlexibleConnectiveSequence):
        """Cache mechanism used in the constructor."""
        hash_value: int = ConnectiveSequence._compute_hash(o)
        if hash_value in cls._cache.keys():
            return cls._cache[hash_value]
        else:
            cls._cache[hash_value] = o
            return o

    @classmethod
    def data_validate_elements(
            cls,
            o: FlexibleConnectiveSequence, raise_exception_on_validation_failure: bool = True) -> \
            tuple[bool, tuple[cl.Connective, ...] | None]:
        """Validates `o` as a collection of connective elements,
        applying implicit conversion as necessary.

        :param o: An collection of elements that may be interpreted as :class:`Connective`.
        :param raise_exception_on_validation_failure: Raises an exception if data validation fails.
        :return: a tuple (v, s) where v is True if data validation was successful, False otherwise,
            and s is a data-validated sequence of connective elements, or None if data validation failed.
        """
        if isinstance(o, ConnectiveSequence):
            # data validation is assured by the class logic.
            return True, o
        if isinstance(o, collections.abc.Iterable) or isinstance(o, collections.abc.Generator):
            v: bool = True
            o = tuple(o)
            c: cl.FlexibleConnective
            l: list[cl.Connective] = list()
            for c in o:
                try:
                    c: cl.Connective = cl.Connective.from_any(c)
                except util.PunctiliousException:
                    if raise_exception_on_validation_failure:
                        raise util.PunctiliousException(
                            "Some element `c` of `o` is not interpretable as a connective.", c=c, o=o)
                    else:
                        v = False
            return v, o if v else None
        if raise_exception_on_validation_failure:
            raise util.PunctiliousException("The type of `o` is not supported.", o_type=type(o), o=o)
        else:
            return False, None

    @functools.cached_property
    def elements(self) -> tuple[int, ...]:
        """The elements that compose this `ConnectiveSequence`, in order.

        :return:
        """
        return tuple(super().__iter__())

    @util.readonly_class_property
    def is_equal_to_relation(cls) -> typing.Type[brl.BinaryRelation]:
        return IsEqualTo

    @classmethod
    def from_any(cls, o: FlexibleConnectiveSequence) -> ConnectiveSequence:
        """Declares a connective-sequence from a Python object that can be interpreted as a connective-sequence.

        Note:
            This method is redundant with the default constructor.

        :param o: a Python object that can be interpreted as a connective-sequence.
        :return: a connective-sequence.
        """
        if isinstance(o, ConnectiveSequence):
            return o
        if isinstance(o, collections.abc.Iterable):
            return ConnectiveSequence(*o)
        if isinstance(o, collections.abc.Generator):
            return ConnectiveSequence(*o)
        raise util.PunctiliousException('Connective-sequence data validation failure', o=o)

    def is_connective_sequence_equivalent_to(self, s: FlexibleConnectiveSequence):
        """Returns `True` if this :class:`ConnectiveSequence` is connective-sequence-equivalent
        to :class:`ConnectiveSequence` `s`.

        Formal definition:
        A connective-sequence `s` is connective-sequence-equivalent to a connective-sequence `t` if and only if
         - the length of `t` = the length of `d`,
         - s_i is connective-equivalent to d_i for all i from 0 to length(`t`) - 1.

        :param s:
        :return:
        """
        s: ConnectiveSequence = ConnectiveSequence.from_any(s)
        return all(i == j for i, j in zip(self, s))

    @util.readonly_class_property
    def is_strictly_less_than_relation(cls) -> typing.Type[brl.BinaryRelation]:
        return CombinedFixedLengthIntegersWithSentinelOrder

    @util.readonly_class_property
    def least_element(cls) -> ConnectiveSequence:
        return cls.is_strictly_less_than_relation.least_element

    @functools.cached_property
    def length(self) -> int:
        """The `length` of a finite sequence is the number of elements in the sequence."""
        return len(self)


# Flexible types to facilitate data validation

FlexibleConnectiveSequence = typing.Union[
    ConnectiveSequence, tuple[cl.Connective, ...], collections.abc.Iterator, collections.abc.Generator, None]

# Aliases

CS = ConnectiveSequence  # An alias for ConnectiveSequence.
combined_fixed_length_integers_with_sentinel_order = CombinedFixedLengthIntegersWithSentinelOrder
