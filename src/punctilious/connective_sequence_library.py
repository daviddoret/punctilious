from __future__ import annotations
import itertools
import typing
import collections

# punctilious libraries
import punctilious.util as util
import punctilious.connective_library as cl


# Data validation functions


# General functions


# Classes


class ConnectiveSequence(tuple):
    """A finite (computable) sequence of at least 1 connectives.

    """

    def __eq__(self, s) -> bool:
        """Returns `True` if this connective-sequence is equal to connective-sequence `s`, `False` otherwise.

        See :attr:`ConnectiveSequence.is_equal_to` for a definition of connective-sequence equality.

        :param s: A connective-sequence.
        :return: `True` if this connective-sequence is equal to connective-sequence `s`, `False` otherwise.
        """
        return self.is_equal_to(s)

    def __hash__(self):
        return self._compute_hash(self)

    def __init__(self, *s):
        super(ConnectiveSequence, self).__init__()

    def __lt__(self, s) -> bool:
        """Returns `True` if this connective-sequence is less than formula `s`, `False` otherwise.

        See :attr:`ConnectiveSequence.is_less_than` for a definition of connective-sequence canonical-ordering.

        """
        return self.is_less_than(s)

    def __new__(cls, *s):
        v: bool
        s: tuple[cl.Connective, ...]
        v, s = cls.data_validate_elements(s)
        if len(s) < 1:
            raise util.PunctiliousException('The length of a ConnectiveSequence must be strictly greater than ')
        s: tuple[cl.Connective] = super(ConnectiveSequence, cls).__new__(cls, s)
        s: tuple[cl.Connective] = cls._from_cache(s)
        return s

    _cache: dict[
        int, ConnectiveSequence] = dict()  # cache for ConnectiveSequence.

    _HASH_SEED: int = 642062802475784292  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @classmethod
    def _compute_hash(cls, o: FlexibleConnectiveSequence) -> int:
        """Exposes the hashing logic as a static method.

        :param o: An object that is structurally compatible with a natural-number-sequence.
        :return: The hash of the natural-number-sequence that is structurally equivalent to `o`.
        """
        return hash((ConnectiveSequence, cls._HASH_SEED, o.elements,))

    @classmethod
    def _from_cache(cls, o: FlexibleConnectiveSequence):
        """Cache mechanism used in the constructor."""
        hash_value: int = ConnectiveSequence._compute_hash(o)
        if hash_value in cls._cache.keys():
            return cls._cache[hash_value]
        else:
            cls._cache[hash_value] = o
            return o

    @classmethod
    def data_validate_elements(
            cls,
            o: FlexibleConnectiveSequence, raise_exception_on_validation_failure: bool = True) -> \
            tuple[bool, tuple[cl.Connective, ...] | None]:
        """Validates `o` as a collection of connective elements,
        applying implicit conversion as necessary.

        :param o: An collection of elements that may be interpreted as :class:`Connective`.
        :param raise_exception_on_validation_failure: Raises an exception if data validation fails.
        :return: a tuple (v, s) where v is True if data validation was successful, False otherwise,
            and s is a data-validated sequence of connective elements, or None if data validation failed.
        """
        if isinstance(o, ConnectiveSequence):
            # data validation is assured by the class logic.
            return True, o
        if isinstance(o, collections.abc.Iterable) or isinstance(o, collections.abc.Generator):
            v: bool = True
            o = tuple(o)
            if len(o) == 0:
                if raise_exception_on_validation_failure:
                    raise util.PunctiliousException(
                        "`o` is empty.", o=o)
                else:
                    v = False
            c: cl.FlexibleConnective
            l: list[cl.Connective] = list()
            for c in o:
                try:
                    c: cl.Connective = cl.Connective.from_any(c)
                except util.PunctiliousException:
                    if raise_exception_on_validation_failure:
                        raise util.PunctiliousException(
                            "Some element `c` of `o` is not interpretable as a connective.", c=c, o=o)
                    else:
                        v = False
            return v, o if v else None
        if raise_exception_on_validation_failure:
            raise util.PunctiliousException("The type of `o` is not supported.", o_type=type(o), o=o)
        else:
            return False, None

    @property
    def elements(self) -> tuple[int, ...]:
        """The elements that compose this `ConnectiveSequence`, in order.

        :return:
        """
        return tuple(super().__iter__())

    @classmethod
    def from_any(cls, o: FlexibleConnectiveSequence) -> ConnectiveSequence:
        """Declares a connective-sequence from a Python object that can be interpreted as a connective-sequence.

        Note:
            This method is redundant with the default constructor.

        :param o: a Python object that can be interpreted as a connective-sequence.
        :return: a connective-sequence.
        """
        if isinstance(o, ConnectiveSequence):
            return o
        if isinstance(o, collections.abc.Iterable):
            return ConnectiveSequence(*o)
        if isinstance(o, collections.abc.Generator):
            return ConnectiveSequence(*o)
        raise util.PunctiliousException('Connective-sequence data validation failure', o=o)

    def is_connective_sequence_equivalent_to(self, s: FlexibleConnectiveSequence):
        """Returns `True` if this :class:`ConnectiveSequence` is connective-sequence-equivalent
        to :class:`ConnectiveSequence` `s`.

        Formal definition:
        A connective-sequence `s` is connective-sequence-equivalent to a connective-sequence `t` if and only if
         - the length of `t` = the length of `d`,
         - s_i is connective-equivalent to d_i for all i from 0 to length(`t`) - 1.

        :param s:
        :return:
        """
        s: ConnectiveSequence = ConnectiveSequence.from_any(s)
        return all(i == j for i, j in zip(self, s))

    def is_equal_to(self, c: FlexibleConnectiveSequence):
        """Under :class:`ConnectiveSequence` canonical ordering,
        returns `True` if the current :class:`ConnectiveSequence` is equal to `c`,
        `False` otherwise.

        See :attr:`ConnectiveSequence.is_less_than` for a definition of connective-sequence canonical-ordering.

        :param c: A :class:`ConnectiveSequence`.
        :return: `True` if the current :class:`ConnectiveSequence` is equal to `c`, `False` otherwise.
        """
        c: ConnectiveSequence = ConnectiveSequence.from_any(c)
        return self.is_connective_sequence_equivalent_to(c)

    def is_less_than(self, c: FlexibleConnectiveSequence) -> bool:
        r"""Under :class:`ConnectiveSequence` canonical ordering,
        returns `True` if the current :class:`ConnectiveSequence` is less than `c`,
        `False` otherwise.

        Definition: canonical ordering of natural-number-sequence, denoted :math:`\prec`,
        is defined as length-first, ascending-order second.

        Note:
        The canonical ordering of connective-sequence being dependent on the connectives UUIDs,
        the resulting ordering may appear random to the human reader.

        :param c: A :class:`ConnectiveSequence`.
        :return: `True` if the current :class:`ConnectiveSequence` is equal to `c`, `False` otherwise.
        """
        c: ConnectiveSequence = ConnectiveSequence.from_any(c)
        if self.is_connective_sequence_equivalent_to(c):
            return False
        elif self.length < c.length:
            return True
        elif self.length > c.length:
            return False
        else:
            for n, m in zip(self.elements, c.elements):
                if n < m:
                    return True
                if n > m:
                    return False
        raise util.PunctiliousException("Unreachable condition")

    @property
    def length(self) -> int:
        """The `length` of a finite sequence is the number of elements in the sequence."""
        return len(self)


# Flexible types to facilitate data validation

FlexibleConnectiveSequence = typing.Union[
    ConnectiveSequence, tuple[cl.Connective, ...], collections.abc.Iterator, collections.abc.Generator, None]

# Aliases

CS = ConnectiveSequence  # An alias for ConnectiveSequence.
