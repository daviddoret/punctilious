from __future__ import annotations
import typing
import binary_relation_library as orl
import util


# Relation classes


class IsEqualTo(orl.BinaryRelation):
    r"""The equality binary-relation for 0-based natural numbers.

    Mathematical definition
    -------------------------

    :math:`( \mathbb{N}_0, = )`.

    """

    # mathematical properties
    _is_antisymmetric: bool | None = True
    _is_asymmetric: bool | None = False
    _is_connected: bool | None = False
    _is_irreflexive: bool | None = False
    _is_reflexive: bool | None = True
    _is_strongly_connected: bool | None = False
    _is_symmetric: bool | None = True
    _is_transitive: bool | None = True

    def relates(self, x: object, y: object) -> bool:
        x: NaturalNumber0 = NaturalNumber0.from_any(x)
        y: NaturalNumber0 = NaturalNumber0.from_any(y)
        return int(x) == int(y)


class IsStrictlyGreaterThan(orl.BinaryRelation):
    r"""The natural order inverse of natural numbers starting at 0.

    Mathematical definition
    -------------------------

    :math:`( \mathbb{N}^{+}, > )`.

    """

    # mathematical properties
    _is_antisymmetric: bool | None = True
    _is_asymmetric: bool | None = None
    _is_connected: bool | None = None
    _is_irreflexive: bool | None = True
    _is_reflexive: bool | None = None
    _is_strongly_connected: bool | None = None
    _is_transitive: bool | None = True

    def relates(self, x: object, y: object) -> bool:
        x: NaturalNumber0 = NaturalNumber0.from_any(x)
        y: NaturalNumber0 = NaturalNumber0.from_any(y)
        return int(x) > int(y)


class IsStrictlyLessThan(orl.BinaryRelation):
    r"""The natural order of natural numbers starting at 0.

    Mathematical definition
    -------------------------

    :math:`( \mathbb{N}^{+}, < )`.

    """

    # mathematical properties
    _is_antisymmetric: bool | None = None
    _is_asymmetric: bool | None = True
    _is_connected: bool | None = None
    _is_irreflexive: bool | None = True
    _is_reflexive: bool | None = None
    _is_strongly_connected: bool | None = None
    _is_transitive: bool | None = True

    def relates(self, x: object, y: object) -> bool:
        x: NaturalNumber0 = NaturalNumber0.from_any(x)
        y: NaturalNumber0 = NaturalNumber0.from_any(y)
        return int(x) < int(y)


# Relations

is_equal_to: IsEqualTo = IsEqualTo()  # The canonical equality relation for natural-number-0 elements.
is_strictly_greater_than: IsStrictlyGreaterThan = IsStrictlyGreaterThan()  # The canonical is-strictly-greater-than relation for natural-number-0 elements.
is_strictly_less_than: IsStrictlyLessThan = IsStrictlyLessThan()  # The canonical is-strictly-less-than relation for natural-number-0 elements.


# Main class

class NaturalNumber0(orl.RelationalElement, int):
    r"""A 0-based natural number.

    Mathematical definition
    -------------------------

    :math:`\mathbb{N}^{+}`.


    """

    _HASH_SEED: int = 13673191340634779527  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    # Configuration of class properties (cf. Relatable).
    _is_equal_to: orl.BinaryRelation = is_equal_to
    _is_strictly_greater_than: orl.BinaryRelation = is_strictly_greater_than
    _is_strictly_less_than: orl.BinaryRelation = is_strictly_less_than

    def __hash__(self):
        return hash((NaturalNumber0, NaturalNumber0._HASH_SEED, int(self),))

    def __new__(cls, x):
        x = int(x)
        if x < 0:
            raise util.PunctiliousException("`x` is less than 0.", x=x)
        return super().__new__(cls, x)

    def __str__(self):
        return str(int(self))

    @classmethod
    def from_any(cls, o: object) -> NaturalNumber0:
        r"""Declares a natural-number-0 from a Python object that can be interpreted as a natural-number-sequence.

        :param o: A Python object that can be interpreted as a natural-number-sequence.
        :return: A natural-number-sequence.
        """
        if isinstance(o, NaturalNumber0):
            return o
        if isinstance(o, int):
            return NaturalNumber0(o)
        raise util.PunctiliousException('Failure to interpret `o` as a natural-number-0.', o_type=type(o), o=o)


# Flexible types to facilitate data validation

FlexibleNaturalNumber0 = typing.Union[
    NaturalNumber0, int]

# Aliases

NN0 = NaturalNumber0  # An alias for NaturalNumber0
