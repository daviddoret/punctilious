from __future__ import annotations
import typing
import collections
import collections.abc

# package modules
import punctilious.util as util
import punctilious.connective_library as cl
import punctilious.abstract_formula_library as afl
import punctilious.natural_number_sequence_library as sl
import punctilious.connective_sequence_library as csl


# Classes


class Formula(tuple):
    """

    Definition
    _____________

    A `Formula` is a pair (ϕ, M) where:

    - ϕ is an abstract formula of tree-size n.
    - M is a bijective map between the subset of natural-numbers N,
       and a set of connectives C.

    """

    def __eq__(self, phi) -> bool:
        """Returns `True` if this formula is equal to formula `phi`, `False` otherwise.

        See :attr:`Formula.is_equal_to` for a definition of formula equality.

        :param phi: A formula.
        :return: `True` if this formula is equal to formula `c`, `False` otherwise.
        """
        return self.is_equal_to(phi)

    def __hash__(self):
        return self._compute_hash(self)

    def __init__(self, phi: afl.FlexibleAbstractFormula, s: sl.FlexibleConnectiveSequence):
        super(Formula, self).__init__()
        self._immediate_sub_formulas = None
        self._sub_formulas = None

    def __lt__(self, phi) -> bool:
        """Returns `True` if this formula is less than formula `phi`, `False` otherwise.

        See :attr:`Formula.is_less_than` for a definition of formula canonical-ordering.

        """
        return self.is_less_than(phi)

    def __new__(cls, phi: afl.FlexibleAbstractFormula, s: csl.FlexibleConnectiveSequence):
        phi: afl.AbstractFormula = afl.AbstractFormula.from_any(phi)
        s: csl.ConnectiveSequence = csl.ConnectiveSequence.from_any(s)
        phi: afl.AbstractFormula = phi.canonical_abstract_formula  # Canonize the abstract-formula
        if s.length != phi.natural_number_sequence.image_cardinality:
            raise util.PunctiliousException(
                f"`Formula` data validation error. The length of the `ConnectiveSequence` `s`"
                f" is not equal to the `image_cardinality` of the `natural_number_sequence` of its"
                f" `abstract_formula`.",
                s_length=s.length, phi_tree_size=phi.tree_size, s=s, phi=phi)
        psi = super(Formula, cls).__new__(cls, (phi, s,))
        psi = cls._from_cache(psi)
        return psi

    def __repr__(self):
        return self.represent_as_function()

    def __str__(self):
        return self.represent_as_function()

    _cache: dict[int, Formula] = dict()  # Cache mechanism.

    _HASH_SEED: int = 11701184968249671969  # A static random seed to reduce collision risk, originally generated by random.getrandbits(64).

    @property
    def arity(self) -> int:
        r"""Returns the arity of the formula.

        Definition: arity of a formula
        The arity of a formula :math:`\Phi = (\Psi, S)`
        where math:`Psi` is an abstract-formula, and :math:`S` is a connective-sequence,
        is the arity of its abstract-formula :math:`Psi`.

        :return: the arity of the formula.
        """
        return self.abstract_formula.arity

    @classmethod
    def _compute_hash(cls, o: Formula) -> int:
        r"""Exposes the hashing logic as a static method.

        :param o: An object that is structurally compatible with an formula.
        :return: The hash of the formula that is structurally equivalent to `o`.
        """
        return hash((Formula, cls._HASH_SEED, o.abstract_formula, o.connective_sequence,))

    @classmethod
    def _from_cache(cls, o: FlexibleFormula):
        """Cache mechanism used in the constructor."""
        hash_value: int = Formula._compute_hash(o)
        if hash_value in cls._cache.keys():
            return cls._cache[hash_value]
        else:
            cls._cache[hash_value] = o
            return o

    @property
    def abstract_formula(self) -> afl.AbstractFormula:
        """

        `abstract_formula` is an immutable property.


        :return:
        """
        return tuple.__getitem__(self, 0)

    @property
    def connective_sequence(self) -> csl.ConnectiveSequence:
        """

        `connective_sequence` is an immutable property.


        :return:
        """
        return tuple.__getitem__(self, 1)

    @property
    def formula_degree(self) -> int:
        """The `formula_degree` of a `Formula` is the number of non-leaf nodes it contains.

        This definition is derived from (Mancosu et al, 2021, p. 18).

        Attention point: do not confuse `tree_size` and `formula_degree`.

        :return:
        """
        return self.abstract_formula.formula_degree

    @classmethod
    def from_any(cls,
                 o: FlexibleFormula) -> Formula:
        if isinstance(o, Formula):
            return o
        if isinstance(o, collections.abc.Iterable):
            return Formula(*o)
        if isinstance(o, collections.abc.Generator):
            return Formula(*o)
        raise util.PunctiliousException('Formula data validation failure', o=o)

    def get_connective_by_sequence_element(self, i: int) -> cl.Connective:
        return self.connective_sequence[i]

    @property
    def immediate_sub_formulas(self) -> tuple[Formula, ...]:
        """The `immediate_sub_formulas` of a `Formula` `phi` is the tuple of `Formula` elements that are the
        immediate children formulas of `phi` in the formula tree, or equivalently the formulas of degree 0 in `phi`.

        The term `immediate sub-formula` is used by (Mancosu 2021, p. 17-18) in the context of propositional logic.

        See also:
        - :attr:`Formula.sub_formulas`

        References:
        - Mancosu 2021.

        :return:
        """
        if self._sub_formulas is None:
            sub_formulas: list[Formula] = list()
            for sub_formula in self.iterate_immediate_sub_formulas():
                sub_formulas.append(sub_formula)
            self._sub_formulas = tuple(sub_formulas)
        return self._sub_formulas

    def is_equal_to(self, t: FlexibleFormula):
        """Returns `True` if this formula is equal to formula `t`, `False` otherwise.

        Definition - formula equality:
        In the context of the formula canonical ordering,
        equality is defined as formula equivalence.

        See :attr:`Formula.is_less_than` for a definition of formula canonical-ordering.

        :param t: A formula.
        :return: `True` if the current formula is equal to `t`, `False` otherwise.
        """
        return self.is_formula_equivalent_to(t)

    def is_formula_equivalent_to(self, phi: Formula):
        """Returns `True` if this :class:`Formula` is formula-equivalent
        to :class:`Formula` `phi`.

        Formal definition:
        Two formulas phi and psi are formula-equivalent if and only if:
        - the abstract-formula of phi is abstract-formula-equivalent to the abstract-formula of psi,
        - the connective-sequence of phi is connective-sequence-equivalent to the connective-sequence of psi.

        :param phi:
        :return:
        """
        phi: Formula = Formula.from_any(phi)
        return self.abstract_formula.is_abstract_formula_equivalent_to(
            phi.abstract_formula) and self.connective_sequence.is_connective_sequence_equivalent_to(
            phi.connective_sequence)

    def is_immediate_sub_formula_of(self, phi: Formula) -> bool:
        """Returns `True` if `phi` is an immediate sub-formula of the current `Formula`, `False` otherwise.

        :param phi:
        :return:
        """
        phi: Formula = Formula.from_any(phi)
        return any(self.is_formula_equivalent_to(psi) for psi in phi.iterate_immediate_sub_formulas())

    def is_immediate_super_formula_of(self, phi: Formula):
        """Returns `True` if :class:`Formula` phi is an immediate sub-formula of this :class:`Formula`.

        :param phi:
        :return:
        """
        phi: Formula = Formula.from_any(phi)
        return phi.is_immediate_sub_formula_of(self)

    @property
    def is_increasing(self) -> bool:
        r"""Returns `True` if this formula is increasing, `False` otherwise.

        Definition - increasing formula:
        An formula is increasing
        or increasing under canonical order,
        if its immediate subformulas are ordered.

        Definition - increasing formula:
        A formula :math:`\phi = c(\psi_0, \psi1, \cdots, \psi_l)` is increasing,
        or increasing under canonical order,
        if and only if :math:`\forall i \in \{ 0, 1, \cdots, l - 1 \}, \psi_{i + 1} \ge \psi_i`.

        :return: `True` if this formula is increasing, `False` otherwise.
        """
        return all(
            self.immediate_sub_formulas[i + 1] >= self.immediate_sub_formulas[i] for i in range(0, self.arity - 1))

    @property
    def is_strictly_increasing(self) -> bool:
        r"""Returns `True` if this formula is strictly increasing, `False` otherwise.

        Definition - strictly increasing formula:
        An formula is strictly increasing
        or strictly increasing under canonical order,
        if its immediate subformulas are strictly ordered.

        Definition - strictly increasing formula:
        A formula :math:`\phi = c(\psi_0, \psi1, \cdots, \psi_l)` is strictly increasing,
        or strictly increasing under canonical order,
        if and only if :math:`\forall i \in \{ 0, 1, \cdots, l - 1 \}, \psi_{i + 1} > \psi_i`.

        :return: `True` if this formula is strictly increasing, `False` otherwise.
        """
        return all(
            self.immediate_sub_formulas[i + 1] > self.immediate_sub_formulas[i] for i in range(0, self.arity - 1))

    def is_less_than(self, phi: FlexibleFormula) -> bool:
        r"""Under :class:`Formula` canonical ordering,
        returns `True` if the current :class:`Formula` is less than `phi`,
        `False` otherwise.

        Definition: canonical ordering of formula, denoted :math:`\prec`,
        is defined as abstract-formula first, connective-sequence second.

        Note:
        The canonical ordering of connective-sequence being dependent on the connectives UUIDs,
        the resulting ordering may appear random to the human reader.

        :param phi: A :class:`Formula`.
        :return: `True` if the current :class:`Formula` is equal to `phi`, `False` otherwise.
        """
        phi: Formula = Formula.from_any(phi)
        if self.is_formula_equivalent_to(phi):
            return False
        elif self.abstract_formula.is_less_than(phi.abstract_formula):
            return True
        elif phi.abstract_formula.is_less_than(self.abstract_formula):
            return False
        elif self.connective_sequence.is_less_than(phi.connective_sequence):
            return True
        elif phi.connective_sequence.is_less_than(self.connective_sequence):
            return False
        raise util.PunctiliousException("Unreachable condition")

    def is_sub_formula_of(self, phi: Formula) -> bool:
        """Returns `True` if `phi` is a sub-formula of the current `Formula`, `False` otherwise.

        :param phi:
        :return:
        """
        phi: Formula = Formula.from_any(phi)
        return any(self.is_formula_equivalent_to(psi) for psi in phi.iterate_sub_formulas())

    def is_super_formula_of(self, phi: Formula):
        """Returns `True` if :class:`Formula` phi is a sub-formula of this :class:`Formula`.

        :param phi:
        :return:
        """
        phi: Formula = Formula.from_any(phi)
        return phi.is_sub_formula_of(self)

    def iterate_connectives(self) -> collections.abc.Generator[cl.Connective, None, None]:
        """Iterate the `Formula` connectives, following the depth-first, ascending-nodes algorithm.

        :return: None
        """
        i: int
        c: cl.Connective
        for i in self.abstract_formula.natural_number_sequence:
            yield self.get_connective_by_sequence_element(i)

    def iterate_immediate_sub_formulas(self) -> collections.abc.Generator[Formula, None, None]:
        """Iterates the immediate sub-formulas of the :class:`Formula`.

        See :attr:`Formula.immediate_sub_formulas` for a definition of the term `immediate sub-formula`.

        :return: A generator of :class:`Formula`.
        """
        for phi, s in zip(self.abstract_formula.iterate_immediate_sub_formulas(),
                          self.abstract_formula.iterate_immediate_sub_sequences()):
            s: tuple[int, ...] = util.deduplicate_integer_sequence(s)
            t: tuple[cl.Connective, ...] = tuple(
                self.get_connective_by_sequence_element(i) for i in s)
            yield Formula(phi, t)

    def iterate_sub_formulas(self) -> collections.abc.Generator[Formula, None, None]:
        for phi, s in zip(self.abstract_formula.iterate_sub_formulas(),
                          self.abstract_formula.iterate_sub_sequences()):
            s: tuple[int, ...] = util.deduplicate_integer_sequence(s)
            t: tuple[cl.Connective, ...] = tuple(
                self.get_connective_by_sequence_element(i) for i in s)
            yield Formula(phi, t)

    @property
    def main_connective(self) -> cl.Connective:
        """The `main_connective` of a :class:`Formula` `phi` is the :class:`Connective` that corresponds
        to the root node of the formula tree.

        By definition of a :class:`Formula` as a pair (phi, S) where S is sequence of connectives,
        the `main_connective` is the first element of S.

        The term `main connective` is defined by Mancosu 2021, p. 17 in the context of propositional logic.

        References:
         - Mancosu 2021

        :return: a :class:`Connective`
        """
        return self.connective_sequence[0]

    def represent_as_function(self) -> str:
        """Returns a string representation of the `Formula` using function notation.
        """
        # TODO: TEST THIS
        return self.abstract_formula.represent_as_function(connectives=self.connective_sequence)

    @property
    def sequence_max_value(self) -> int:
        """The `sequence_max_value` of a `Formula` is the `sequence_max_value` of its `abstract_formula`."""
        return self.abstract_formula.sequence_max_value

    @property
    def sub_formulas(self) -> tuple[Formula, ...]:
        """The `sub_formulas` of an `Formula` `phi` is the tuple of `Formula` elements that are present
        in the formula tree of `phi`, including `phi` itself.

        Formal definition
        ____________________

        - If phi is an atomic formula, the sub-formulas of phi is the tuple (phi).
        - If phi is a non-atomic formula, the sub-formulas of phi is the tuple
           composed of phi, and all sub-formulas of the immediate sub-formulas of phi,
           in ascending order.
        - Nothing else is a sub-formula.

        This definition is a generalization of the term `formula` defined by (Mancosu 2021, definition 2.2, p. 14)
        for propositional-logic.

        See also
        __________

        - :attr:`Formula.immediate_sub_formulas`

        References
        ____________

        - Mancosu 2021.

        :return: A tuple of the sub-formulas.

        """
        if self._sub_formulas is None:
            sub_formulas: list[Formula] = list()
            for sub_formula in self.iterate_sub_formulas():
                sub_formulas.append(sub_formula)
            self._sub_formulas = tuple(sub_formulas)
        return self._sub_formulas

    def substitute_sub_formulas(self, m: dict[FlexibleFormula, FlexibleFormula]) -> Formula:
        """Returns a new :class:`Formula` similar to the current :class:`Formula` except that
        all sub-formulas present in the map `m` domain,
        are substituted with corresponding :class:`Formula` elements in map `m` codomain,
        following the depth-first, ascending-nodes algorithm.

        :param m: A map Formula --> Formula.
        :return:
        """
        domain: tuple[Formula, ...] = tuple(Formula.from_any(x) for x in m.keys())
        codomain: tuple[Formula, ...] = tuple(Formula.from_any(y) for y in m.values())
        m: dict[Formula, Formula] = dict(zip(domain, codomain))
        sub_formulas: list[Formula] = []
        immediate_abstract_formulas: list[afl.AbstractFormula] = []
        for phi in self.iterate_immediate_sub_formulas():
            if phi in m.keys():
                psi = m[phi]
                sub_formulas.append(psi)
                immediate_abstract_formulas.append(psi.abstract_formula)
            else:
                sub_formulas.append(phi)
                immediate_abstract_formulas.append(phi.abstract_formula)
        abstract_formula: afl.AbstractFormula = afl.AbstractFormula()
        raise NotImplementedError("Complete implementation")

    @property
    def tree_size(self) -> int:
        """The `tree_size` of a `Formula` is the number of vertices in the `RootedPlaneTree` of its `abstract_formula`.

        Attention point: do not confuse `tree_size` and `formula_degree`.
        """
        return self.abstract_formula.tree_size


# Data types

FlexibleFormula = typing.Union[
    Formula, tuple[
        csl.FlexibleConnectiveSequence, afl.FlexibleAbstractFormula], collections.abc.Iterator, collections.abc.Generator, None]
