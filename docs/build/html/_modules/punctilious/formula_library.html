<!DOCTYPE html>

<html lang="en" data-content_root="../../">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>punctilious.formula_library &#8212; Punctilious 1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2"/>
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9"/>
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d"/>
    <script src="../../_static/documentation_options.js?v=29a6c3e3"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html"/>
    <link rel="search" title="Search" href="../../search.html"/>

    <link rel="stylesheet" href="../../_static/custom.css" type="text/css"/>


</head>
<body>


<div class="document">
    <div class="documentwrapper">
        <div class="bodywrapper">


            <div class="body" role="main">

                <h1>Source code for punctilious.formula_library</h1>
                <div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span
                        class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">typing</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections.abc</span>

<span class="c1"># package modules</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">punctilious.util</span><span
                        class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">util</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">punctilious.connective_library</span><span
                        class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cl</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">punctilious.abstract_formula_library</span><span
                        class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">afl</span>
<span class="kn">import</span><span class="w"> </span><span
                        class="nn">punctilious.natural_number_1_sequence_library</span><span class="w"> </span><span
                        class="k">as</span><span class="w"> </span><span class="nn">sl</span>
<span class="kn">import</span><span class="w"> </span><span
                        class="nn">punctilious.connective_sequence_library</span><span class="w"> </span><span
                        class="k">as</span><span class="w"> </span><span class="nn">csl</span>


<span class="c1"># Classes</span>


<div class="viewcode-block" id="Formula">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Formula</span><span class="p">(</span><span
        class="nb">tuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Definition</span>
<span class="sd">    _____________</span>

<span class="sd">    A `Formula` is a pair (ϕ, M) where:</span>

<span class="sd">    - ϕ is an abstract formula of tree-size n.</span>
<span class="sd">    - M is a bijective map between the subset of natural-numbers N,</span>
<span class="sd">       and a set of connectives C.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span
        class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if this formula is equal to formula `phi`, `False` otherwise.</span>

<span class="sd">        See :attr:`Formula.is_equal_to` for a definition of formula equality.</span>

<span class="sd">        :param phi: A formula.</span>
<span class="sd">        :return: `True` if this formula is equal to formula `c`, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">is_equal_to</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span
        class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">_compute_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Formula.__init__">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span
        class="n">afl</span><span class="o">.</span><span class="n">FlexibleAbstractFormula</span><span
        class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">sl</span><span
        class="o">.</span><span class="n">FlexibleConnectiveSequence</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Formula</span><span
        class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span
        class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_immediate_sub_formulas</span> <span
        class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sub_formulas</span> <span
        class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span
        class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if this formula is less than formula `phi`, `False` otherwise.</span>

<span class="sd">        See :attr:`Formula.is_less_than` for a definition of formula canonical-ordering.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">is_less_than</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span
        class="bp">cls</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span
        class="n">afl</span><span class="o">.</span><span class="n">FlexibleAbstractFormula</span><span
        class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">csl</span><span
        class="o">.</span><span class="n">FlexibleConnectiveSequence</span><span class="p">):</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">afl</span><span class="o">.</span><span
        class="n">AbstractFormula</span> <span class="o">=</span> <span class="n">afl</span><span
        class="o">.</span><span class="n">AbstractFormula</span><span class="o">.</span><span
        class="n">from_any</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">s</span><span class="p">:</span> <span class="n">csl</span><span class="o">.</span><span
        class="n">ConnectiveSequence</span> <span class="o">=</span> <span class="n">csl</span><span
        class="o">.</span><span class="n">ConnectiveSequence</span><span class="o">.</span><span
        class="n">from_any</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">afl</span><span class="o">.</span><span
        class="n">AbstractFormula</span> <span class="o">=</span> <span class="n">phi</span><span
        class="o">.</span><span class="n">canonical_abstract_formula</span>  <span class="c1"># Canonize the abstract-formula</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span
        class="o">!=</span> <span class="n">phi</span><span class="o">.</span><span
        class="n">natural_number_sequence</span><span class="o">.</span><span class="n">image_cardinality</span><span
        class="p">:</span>
            <span class="k">raise</span> <span class="n">util</span><span class="o">.</span><span class="n">PunctiliousException</span><span
        class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`Formula` data validation error. The length of the `ConnectiveSequence` `s`&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; is not equal to the `image_cardinality` of the `natural_number_sequence` of its&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; `abstract_formula`.&quot;</span><span
        class="p">,</span>
                <span class="n">s_length</span><span class="o">=</span><span class="n">s</span><span
        class="o">.</span><span class="n">length</span><span class="p">,</span> <span
        class="n">phi_tree_size</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span
        class="n">tree_size</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span
        class="n">s</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span
        class="n">phi</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span
        class="n">Formula</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span
        class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span
        class="p">,</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span
        class="n">s</span><span class="p">,))</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span
        class="n">_from_cache</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">psi</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span
        class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as_function</span><span
        class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span
        class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as_function</span><span
        class="p">()</span>

    <span class="n">_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span
        class="nb">int</span><span class="p">,</span> <span class="n">Formula</span><span class="p">]</span> <span
        class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span
        class="c1"># Cache mechanism.</span>

    <span class="n">_HASH_SEED</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
        class="mi">11701184968249671969</span>  <span class="c1"># A static random seed to reduce collision risk, originally generated by random.getrandbits(64).</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">arity</span><span class="p">(</span><span
        class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span
        class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the arity of the formula.</span>

<span class="sd">        Definition: arity of a formula</span>
<span class="sd">        The arity of a formula :math:`\Phi = (\Psi, S)`</span>
<span class="sd">        where math:`Psi` is an abstract-formula, and :math:`S` is a connective-sequence,</span>
<span class="sd">        is the arity of its abstract-formula :math:`Psi`.</span>

<span class="sd">        :return: the arity of the formula.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_formula</span><span
        class="o">.</span><span class="n">arity</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_hash</span><span class="p">(</span><span
        class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Formula</span><span
        class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Exposes the hashing logic as a static method.</span>

<span class="sd">        :param o: An object that is structurally compatible with an formula.</span>
<span class="sd">        :return: The hash of the formula that is structurally equivalent to `o`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span
        class="n">Formula</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span
        class="n">_HASH_SEED</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span
        class="n">abstract_formula</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span
        class="n">connective_sequence</span><span class="p">,))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_cache</span><span class="p">(</span><span
        class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">FlexibleFormula</span><span
        class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cache mechanism used in the constructor.&quot;&quot;&quot;</span>
        <span class="n">hash_value</span><span class="p">:</span> <span class="nb">int</span> <span
        class="o">=</span> <span class="n">Formula</span><span class="o">.</span><span
        class="n">_compute_hash</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hash_value</span> <span class="ow">in</span> <span
        class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span
        class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span
        class="n">_cache</span><span class="p">[</span><span class="n">hash_value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_cache</span><span
        class="p">[</span><span class="n">hash_value</span><span class="p">]</span> <span class="o">=</span> <span
        class="n">o</span>
            <span class="k">return</span> <span class="n">o</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">abstract_formula</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="n">afl</span><span class="o">.</span><span class="n">AbstractFormula</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        `abstract_formula` is an immutable property.</span>


<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="o">.</span><span
        class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span
        class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">connective_sequence</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="n">csl</span><span class="o">.</span><span class="n">ConnectiveSequence</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        `connective_sequence` is an immutable property.</span>


<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="o">.</span><span
        class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span
        class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">formula_degree</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `formula_degree` of a `Formula` is the number of non-leaf nodes it contains.</span>

<span class="sd">        This definition is derived from (Mancosu et al, 2021, p. 18).</span>

<span class="sd">        Attention point: do not confuse `tree_size` and `formula_degree`.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_formula</span><span
        class="o">.</span><span class="n">formula_degree</span>

<div class="viewcode-block" id="Formula.from_any">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula.from_any">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_any</span><span class="p">(</span><span
        class="bp">cls</span><span class="p">,</span>
                 <span class="n">o</span><span class="p">:</span> <span class="n">FlexibleFormula</span><span class="p">)</span> <span
        class="o">-&gt;</span> <span class="n">Formula</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span
        class="n">o</span><span class="p">,</span> <span class="n">Formula</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">o</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span
        class="n">o</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span
        class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Formula</span><span class="p">(</span><span class="o">*</span><span
        class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span
        class="n">o</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span
        class="n">abc</span><span class="o">.</span><span class="n">Generator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Formula</span><span class="p">(</span><span class="o">*</span><span
        class="n">o</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">util</span><span class="o">.</span><span class="n">PunctiliousException</span><span
        class="p">(</span><span class="s1">&#39;Formula data validation failure&#39;</span><span
        class="p">,</span> <span class="n">o</span><span class="o">=</span><span class="n">o</span><span
        class="p">)</span></div>


<div class="viewcode-block" id="Formula.get_connective_by_sequence_element">
<a class="viewcode-back"
   href="../../punctilious.html#punctilious.formula_library.Formula.get_connective_by_sequence_element">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_connective_by_sequence_element</span><span
        class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span
        class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="n">cl</span><span class="o">.</span><span class="n">Connective</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connective_sequence</span><span
        class="p">[</span><span class="n">i</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">immediate_sub_formulas</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="nb">tuple</span><span class="p">[</span><span class="n">Formula</span><span class="p">,</span> <span
        class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `immediate_sub_formulas` of a `Formula` `phi` is the tuple of `Formula` elements that are the</span>
<span class="sd">        immediate children formulas of `phi` in the formula tree, or equivalently the formulas of degree 0 in `phi`.</span>

<span class="sd">        The term `immediate sub-formula` is used by (Mancosu 2021, p. 17-18) in the context of propositional logic.</span>

<span class="sd">        See also:</span>
<span class="sd">        - :attr:`Formula.sub_formulas`</span>

<span class="sd">        References:</span>
<span class="sd">        - Mancosu 2021.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">_sub_formulas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sub_formulas</span><span class="p">:</span> <span class="nb">list</span><span
        class="p">[</span><span class="n">Formula</span><span class="p">]</span> <span class="o">=</span> <span
        class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sub_formula</span> <span class="ow">in</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">iterate_immediate_sub_formulas</span><span class="p">():</span>
                <span class="n">sub_formulas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span
        class="n">sub_formula</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sub_formulas</span> <span
        class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sub_formulas</span><span
        class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">_sub_formulas</span>

<div class="viewcode-block" id="Formula.is_equal_to">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula.is_equal_to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_equal_to</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">FlexibleFormula</span><span
        class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if this formula is equal to formula `t`, `False` otherwise.</span>

<span class="sd">        Definition - formula equality:</span>
<span class="sd">        In the context of the formula canonical ordering,</span>
<span class="sd">        equality is defined as formula equivalence.</span>

<span class="sd">        See :attr:`Formula.is_less_than` for a definition of formula canonical-ordering.</span>

<span class="sd">        :param t: A formula.</span>
<span class="sd">        :return: `True` if the current formula is equal to `t`, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_formula_equivalent_to</span><span
        class="p">(</span><span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="Formula.is_formula_equivalent_to">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula.is_formula_equivalent_to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_formula_equivalent_to</span><span
        class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span
        class="p">:</span> <span class="n">Formula</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if this :class:`Formula` is formula-equivalent</span>
<span class="sd">        to :class:`Formula` `phi`.</span>

<span class="sd">        Formal definition:</span>
<span class="sd">        Two formulas phi and psi are formula-equivalent if and only if:</span>
<span class="sd">        - the abstract-formula of phi is abstract-formula-equivalent to the abstract-formula of psi,</span>
<span class="sd">        - the connective-sequence of phi is connective-sequence-equivalent to the connective-sequence of psi.</span>

<span class="sd">        :param phi:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span
        class="n">Formula</span><span class="o">.</span><span class="n">from_any</span><span class="p">(</span><span
        class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_formula</span><span
        class="o">.</span><span class="n">is_abstract_formula_equivalent_to</span><span class="p">(</span>
            <span class="n">phi</span><span class="o">.</span><span class="n">abstract_formula</span><span
        class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">connective_sequence</span><span class="o">.</span><span
        class="n">is_connective_sequence_equivalent_to</span><span class="p">(</span>
            <span class="n">phi</span><span class="o">.</span><span class="n">connective_sequence</span><span class="p">)</span></div>


<div class="viewcode-block" id="Formula.is_immediate_sub_formula_of">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula.is_immediate_sub_formula_of">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_immediate_sub_formula_of</span><span
        class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span
        class="p">:</span> <span class="n">Formula</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if `phi` is an immediate sub-formula of the current `Formula`, `False` otherwise.</span>

<span class="sd">        :param phi:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span
        class="n">Formula</span><span class="o">.</span><span class="n">from_any</span><span class="p">(</span><span
        class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span
        class="bp">self</span><span class="o">.</span><span class="n">is_formula_equivalent_to</span><span
        class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="k">for</span> <span class="n">psi</span> <span
        class="ow">in</span> <span class="n">phi</span><span class="o">.</span><span class="n">iterate_immediate_sub_formulas</span><span
        class="p">())</span></div>


<div class="viewcode-block" id="Formula.is_immediate_super_formula_of">
<a class="viewcode-back"
   href="../../punctilious.html#punctilious.formula_library.Formula.is_immediate_super_formula_of">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_immediate_super_formula_of</span><span
        class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span
        class="p">:</span> <span class="n">Formula</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if :class:`Formula` phi is an immediate sub-formula of this :class:`Formula`.</span>

<span class="sd">        :param phi:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span
        class="n">Formula</span><span class="o">.</span><span class="n">from_any</span><span class="p">(</span><span
        class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">phi</span><span class="o">.</span><span class="n">is_immediate_sub_formula_of</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_increasing</span><span class="p">(</span><span
        class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span
        class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns `True` if this formula is increasing, `False` otherwise.</span>

<span class="sd">        Definition - increasing formula:</span>
<span class="sd">        An formula is increasing</span>
<span class="sd">        or increasing under canonical order,</span>
<span class="sd">        if its immediate subformulas are ordered.</span>

<span class="sd">        Definition - increasing formula:</span>
<span class="sd">        A formula :math:`\phi = c(\psi_0, \psi1, \cdots, \psi_l)` is increasing,</span>
<span class="sd">        or increasing under canonical order,</span>
<span class="sd">        if and only if :math:`\forall i \in \{ 0, 1, \cdots, l - 1 \}, \psi_{i + 1} \ge \psi_i`.</span>

<span class="sd">        :return: `True` if this formula is increasing, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">immediate_sub_formulas</span><span
        class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span
        class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">immediate_sub_formulas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span
        class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span
        class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">arity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_strictly_increasing</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns `True` if this formula is strictly increasing, `False` otherwise.</span>

<span class="sd">        Definition - strictly increasing formula:</span>
<span class="sd">        An formula is strictly increasing</span>
<span class="sd">        or strictly increasing under canonical order,</span>
<span class="sd">        if its immediate subformulas are strictly ordered.</span>

<span class="sd">        Definition - strictly increasing formula:</span>
<span class="sd">        A formula :math:`\phi = c(\psi_0, \psi1, \cdots, \psi_l)` is strictly increasing,</span>
<span class="sd">        or strictly increasing under canonical order,</span>
<span class="sd">        if and only if :math:`\forall i \in \{ 0, 1, \cdots, l - 1 \}, \psi_{i + 1} &gt; \psi_i`.</span>

<span class="sd">        :return: `True` if this formula is strictly increasing, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">immediate_sub_formulas</span><span
        class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span
        class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">immediate_sub_formulas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span
        class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span
        class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">arity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

<div class="viewcode-block" id="Formula.is_less_than">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula.is_less_than">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_less_than</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span
        class="n">FlexibleFormula</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Under :class:`Formula` canonical ordering,</span>
<span class="sd">        returns `True` if the current :class:`Formula` is less than `phi`,</span>
<span class="sd">        `False` otherwise.</span>

<span class="sd">        Definition: canonical ordering of formula, denoted :math:`\prec`,</span>
<span class="sd">        is defined as abstract-formula first, connective-sequence second.</span>

<span class="sd">        Note:</span>
<span class="sd">        The canonical ordering of connective-sequence being dependent on the connectives UUIDs,</span>
<span class="sd">        the resulting ordering may appear random to the human reader.</span>

<span class="sd">        :param phi: A :class:`Formula`.</span>
<span class="sd">        :return: `True` if the current :class:`Formula` is equal to `phi`, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span
        class="n">Formula</span><span class="o">.</span><span class="n">from_any</span><span class="p">(</span><span
        class="n">phi</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_formula_equivalent_to</span><span
        class="p">(</span><span class="n">phi</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">abstract_formula</span><span class="o">.</span><span class="n">is_less_than</span><span
        class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">abstract_formula</span><span
        class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">phi</span><span class="o">.</span><span
        class="n">abstract_formula</span><span class="o">.</span><span class="n">is_less_than</span><span
        class="p">(</span><span class="bp">self</span><span class="o">.</span><span
        class="n">abstract_formula</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">connective_sequence</span><span
        class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">phi</span><span
        class="o">.</span><span class="n">connective_sequence</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">phi</span><span class="o">.</span><span class="n">connective_sequence</span><span
        class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="bp">self</span><span
        class="o">.</span><span class="n">connective_sequence</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">raise</span> <span class="n">util</span><span class="o">.</span><span class="n">PunctiliousException</span><span
        class="p">(</span><span class="s2">&quot;Unreachable condition&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Formula.is_sub_formula_of">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula.is_sub_formula_of">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_sub_formula_of</span><span
        class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span
        class="p">:</span> <span class="n">Formula</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if `phi` is a sub-formula of the current `Formula`, `False` otherwise.</span>

<span class="sd">        :param phi:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span
        class="n">Formula</span><span class="o">.</span><span class="n">from_any</span><span class="p">(</span><span
        class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span
        class="bp">self</span><span class="o">.</span><span class="n">is_formula_equivalent_to</span><span
        class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="k">for</span> <span class="n">psi</span> <span
        class="ow">in</span> <span class="n">phi</span><span class="o">.</span><span
        class="n">iterate_sub_formulas</span><span class="p">())</span></div>


<div class="viewcode-block" id="Formula.is_super_formula_of">
<a class="viewcode-back"
   href="../../punctilious.html#punctilious.formula_library.Formula.is_super_formula_of">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_super_formula_of</span><span
        class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span
        class="p">:</span> <span class="n">Formula</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if :class:`Formula` phi is a sub-formula of this :class:`Formula`.</span>

<span class="sd">        :param phi:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span
        class="n">Formula</span><span class="o">.</span><span class="n">from_any</span><span class="p">(</span><span
        class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">phi</span><span class="o">.</span><span class="n">is_sub_formula_of</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Formula.iterate_connectives">
<a class="viewcode-back"
   href="../../punctilious.html#punctilious.formula_library.Formula.iterate_connectives">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iterate_connectives</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span
        class="n">Generator</span><span class="p">[</span><span class="n">cl</span><span class="o">.</span><span
        class="n">Connective</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span
        class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate the `Formula` connectives, following the depth-first, ascending-nodes algorithm.</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">int</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">cl</span><span class="o">.</span><span
        class="n">Connective</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">abstract_formula</span><span class="o">.</span><span class="n">natural_number_sequence</span><span
        class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connective_by_sequence_element</span><span
        class="p">(</span><span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="Formula.iterate_immediate_sub_formulas">
<a class="viewcode-back"
   href="../../punctilious.html#punctilious.formula_library.Formula.iterate_immediate_sub_formulas">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iterate_immediate_sub_formulas</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span
        class="n">Generator</span><span class="p">[</span><span class="n">Formula</span><span class="p">,</span> <span
        class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterates the immediate sub-formulas of the :class:`Formula`.</span>

<span class="sd">        See :attr:`Formula.immediate_sub_formulas` for a definition of the term `immediate sub-formula`.</span>

<span class="sd">        :return: A generator of :class:`Formula`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">phi</span><span class="p">,</span> <span class="n">s</span> <span
        class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span
        class="o">.</span><span class="n">abstract_formula</span><span class="o">.</span><span class="n">iterate_immediate_sub_formulas</span><span
        class="p">(),</span>
                          <span class="bp">self</span><span class="o">.</span><span
        class="n">abstract_formula</span><span class="o">.</span><span
        class="n">iterate_immediate_sub_sequences</span><span class="p">()):</span>
            <span class="n">s</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span
        class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span
        class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">deduplicate_integer_sequence</span><span
        class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">t</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span
        class="n">cl</span><span class="o">.</span><span class="n">Connective</span><span class="p">,</span> <span
        class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span
        class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span
        class="n">get_connective_by_sequence_element</span><span class="p">(</span><span class="n">i</span><span
        class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span
        class="n">s</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">Formula</span><span class="p">(</span><span
        class="n">phi</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="Formula.iterate_sub_formulas">
<a class="viewcode-back"
   href="../../punctilious.html#punctilious.formula_library.Formula.iterate_sub_formulas">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iterate_sub_formulas</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span
        class="n">Generator</span><span class="p">[</span><span class="n">Formula</span><span class="p">,</span> <span
        class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">phi</span><span class="p">,</span> <span class="n">s</span> <span
        class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span
        class="o">.</span><span class="n">abstract_formula</span><span class="o">.</span><span class="n">iterate_sub_formulas</span><span
        class="p">(),</span>
                          <span class="bp">self</span><span class="o">.</span><span
        class="n">abstract_formula</span><span class="o">.</span><span class="n">iterate_sub_sequences</span><span
        class="p">()):</span>
            <span class="n">s</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span
        class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span
        class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">deduplicate_integer_sequence</span><span
        class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">t</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span
        class="n">cl</span><span class="o">.</span><span class="n">Connective</span><span class="p">,</span> <span
        class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span
        class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span
        class="n">get_connective_by_sequence_element</span><span class="p">(</span><span class="n">i</span><span
        class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span
        class="n">s</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">Formula</span><span class="p">(</span><span
        class="n">phi</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">main_connective</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="n">cl</span><span class="o">.</span><span class="n">Connective</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `main_connective` of a :class:`Formula` `phi` is the :class:`Connective` that corresponds</span>
<span class="sd">        to the root node of the formula tree.</span>

<span class="sd">        By definition of a :class:`Formula` as a pair (phi, S) where S is sequence of connectives,</span>
<span class="sd">        the `main_connective` is the first element of S.</span>

<span class="sd">        The term `main connective` is defined by Mancosu 2021, p. 17 in the context of propositional logic.</span>

<span class="sd">        References:</span>
<span class="sd">         - Mancosu 2021</span>

<span class="sd">        :return: a :class:`Connective`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connective_sequence</span><span
        class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Formula.represent_as_function">
<a class="viewcode-back"
   href="../../punctilious.html#punctilious.formula_library.Formula.represent_as_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">represent_as_function</span><span
        class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span
        class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string representation of the `Formula` using function notation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: TEST THIS</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_formula</span><span
        class="o">.</span><span class="n">represent_as_function</span><span class="p">(</span><span class="n">connectives</span><span
        class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connective_sequence</span><span
        class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence_max_value</span><span class="p">(</span><span
        class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span
        class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `sequence_max_value` of a `Formula` is the `sequence_max_value` of its `abstract_formula`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_formula</span><span
        class="o">.</span><span class="n">sequence_max_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sub_formulas</span><span class="p">(</span><span
        class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span
        class="p">[</span><span class="n">Formula</span><span class="p">,</span> <span class="o">...</span><span
        class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `sub_formulas` of an `Formula` `phi` is the tuple of `Formula` elements that are present</span>
<span class="sd">        in the formula tree of `phi`, including `phi` itself.</span>

<span class="sd">        Formal definition</span>
<span class="sd">        ____________________</span>

<span class="sd">        - If phi is an atomic formula, the sub-formulas of phi is the tuple (phi).</span>
<span class="sd">        - If phi is a non-atomic formula, the sub-formulas of phi is the tuple</span>
<span class="sd">           composed of phi, and all sub-formulas of the immediate sub-formulas of phi,</span>
<span class="sd">           in ascending order.</span>
<span class="sd">        - Nothing else is a sub-formula.</span>

<span class="sd">        This definition is a generalization of the term `formula` defined by (Mancosu 2021, definition 2.2, p. 14)</span>
<span class="sd">        for propositional-logic.</span>

<span class="sd">        See also</span>
<span class="sd">        __________</span>

<span class="sd">        - :attr:`Formula.immediate_sub_formulas`</span>

<span class="sd">        References</span>
<span class="sd">        ____________</span>

<span class="sd">        - Mancosu 2021.</span>

<span class="sd">        :return: A tuple of the sub-formulas.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">_sub_formulas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sub_formulas</span><span class="p">:</span> <span class="nb">list</span><span
        class="p">[</span><span class="n">Formula</span><span class="p">]</span> <span class="o">=</span> <span
        class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sub_formula</span> <span class="ow">in</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">iterate_sub_formulas</span><span class="p">():</span>
                <span class="n">sub_formulas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span
        class="n">sub_formula</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sub_formulas</span> <span
        class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sub_formulas</span><span
        class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">_sub_formulas</span>

<div class="viewcode-block" id="Formula.substitute_sub_formulas">
<a class="viewcode-back" href="../../punctilious.html#punctilious.formula_library.Formula.substitute_sub_formulas">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">substitute_sub_formulas</span><span
        class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span
        class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span
        class="n">FlexibleFormula</span><span class="p">,</span> <span class="n">FlexibleFormula</span><span class="p">])</span> <span
        class="o">-&gt;</span> <span class="n">Formula</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new :class:`Formula` similar to the current :class:`Formula` except that</span>
<span class="sd">        all sub-formulas present in the map `m` domain,</span>
<span class="sd">        are substituted with corresponding :class:`Formula` elements in map `m` codomain,</span>
<span class="sd">        following the depth-first, ascending-nodes algorithm.</span>

<span class="sd">        :param m: A map Formula --&gt; Formula.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">domain</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span
        class="n">Formula</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span
        class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Formula</span><span
        class="o">.</span><span class="n">from_any</span><span class="p">(</span><span class="n">x</span><span
        class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span
        class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">codomain</span><span class="p">:</span> <span class="nb">tuple</span><span
        class="p">[</span><span class="n">Formula</span><span class="p">,</span> <span class="o">...</span><span
        class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span
        class="n">Formula</span><span class="o">.</span><span class="n">from_any</span><span class="p">(</span><span
        class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span
        class="n">m</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">m</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span
        class="n">Formula</span><span class="p">,</span> <span class="n">Formula</span><span class="p">]</span> <span
        class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span
        class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">codomain</span><span
        class="p">))</span>
        <span class="n">sub_formulas</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span
        class="n">Formula</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">immediate_abstract_formulas</span><span class="p">:</span> <span class="nb">list</span><span
        class="p">[</span><span class="n">afl</span><span class="o">.</span><span class="n">AbstractFormula</span><span
        class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">phi</span> <span class="ow">in</span> <span
        class="bp">self</span><span class="o">.</span><span class="n">iterate_immediate_sub_formulas</span><span
        class="p">():</span>
            <span class="k">if</span> <span class="n">phi</span> <span class="ow">in</span> <span
        class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">psi</span> <span class="o">=</span> <span class="n">m</span><span
        class="p">[</span><span class="n">phi</span><span class="p">]</span>
                <span class="n">sub_formulas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span
        class="n">psi</span><span class="p">)</span>
                <span class="n">immediate_abstract_formulas</span><span class="o">.</span><span
        class="n">append</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span
        class="n">abstract_formula</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sub_formulas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span
        class="n">phi</span><span class="p">)</span>
                <span class="n">immediate_abstract_formulas</span><span class="o">.</span><span
        class="n">append</span><span class="p">(</span><span class="n">phi</span><span class="o">.</span><span
        class="n">abstract_formula</span><span class="p">)</span>
        <span class="n">abstract_formula</span><span class="p">:</span> <span class="n">afl</span><span
        class="o">.</span><span class="n">AbstractFormula</span> <span class="o">=</span> <span
        class="n">afl</span><span class="o">.</span><span class="n">AbstractFormula</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span
        class="s2">&quot;Complete implementation&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tree_size</span><span class="p">(</span><span
        class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span
        class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `tree_size` of a `Formula` is the number of vertices in the `RootedPlaneTree` of its `abstract_formula`.</span>

<span class="sd">        Attention point: do not confuse `tree_size` and `formula_degree`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract_formula</span><span
        class="o">.</span><span class="n">tree_size</span></div>



<span class="c1"># Data types</span>

<span class="n">FlexibleFormula</span> <span class="o">=</span> <span class="n">typing</span><span
                        class="o">.</span><span class="n">Union</span><span class="p">[</span>
    <span class="n">Formula</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">csl</span><span class="o">.</span><span class="n">FlexibleConnectiveSequence</span><span
                        class="p">,</span> <span class="n">afl</span><span class="o">.</span><span class="n">FlexibleAbstractFormula</span><span
                        class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span
                        class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">collections</span><span
                        class="o">.</span><span class="n">abc</span><span class="o">.</span><span
                        class="n">Generator</span><span class="p">,</span> <span class="kc">None</span><span
                        class="p">]</span>
</pre>
                </div>

            </div>

        </div>
    </div>
    <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <h1 class="logo"><a href="../../index.html">Punctilious</a></h1>


            <search id="searchbox" style="display: none" role="search">
                <div class="searchformwrapper">
                    <form class="search" action="../../search.html" method="get">
                        <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off"
                               autocapitalize="off" spellcheck="false" placeholder="Search"/>
                        <input type="submit" value="Go"/>
                    </form>
                </div>
            </search>
            <script>document.getElementById('searchbox').style.display = "block"</script>
            <h3>Navigation</h3>
            <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
            <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../modules.html">punctilious</a></li>
            </ul>

            <div class="relations">
                <h3>Related Topics</h3>
                <ul>
                    <li><a href="../../index.html">Documentation overview</a>
                        <ul>
                            <li><a href="../index.html">Module code</a>
                                <ul>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>


        </div>
    </div>
    <div class="clearer"></div>
</div>
<div class="footer">
    &#169;2025, David Doret.

    |
    Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.3.0</a>
    &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>

</div>


</body>
</html>